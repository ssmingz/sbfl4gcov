        -:    0:Source:/mnt/hwshare/gcov_mysql/mysql_9_dfb4f427442f5fc4112a4847c09e1c51e420077c_pre/vio/viosocket.cc
        -:    0:Graph:viosocket.cc.gcno
        -:    0:Data:viosocket.cc.gcda
        -:    0:Runs:4
        -:    0:Programs:2
        -:    1:/*
        -:    2:   Copyright (c) 2001, 2021, Oracle and/or its affiliates.
        -:    3:
        -:    4:   This program is free software; you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License, version 2.0,
        -:    6:   as published by the Free Software Foundation.
        -:    7:
        -:    8:   This program is also distributed with certain software (including
        -:    9:   but not limited to OpenSSL) that is licensed under separate terms,
        -:   10:   as designated in a particular file or component or in included license
        -:   11:   documentation.  The authors of MySQL hereby grant you an additional
        -:   12:   permission to link the program and your derivative works with the
        -:   13:   separately licensed software that they have included with MySQL.
        -:   14:
        -:   15:   Without limiting anything contained in the foregoing, this file,
        -:   16:   which is part of C Driver for MySQL (Connector/C), is also subject to the
        -:   17:   Universal FOSS Exception, version 1.0, a copy of which can be found at
        -:   18:   http://oss.oracle.com/licenses/universal-foss-exception.
        -:   19:
        -:   20:   This program is distributed in the hope that it will be useful,
        -:   21:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   22:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   23:   GNU General Public License, version 2.0, for more details.
        -:   24:
        -:   25:   You should have received a copy of the GNU General Public License
        -:   26:   along with this program; if not, write to the Free Software
        -:   27:   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */
        -:   28:
        -:   29:/*
        -:   30:  Note that we can't have assertion on file descriptors;  The reason for
        -:   31:  this is that during mysql shutdown, another thread can close a file
        -:   32:  we are working on.  In this case we should just return read errors from
        -:   33:  the file descriptior.
        -:   34:*/
        -:   35:
        -:   36:#include "my_config.h"
        -:   37:
        -:   38:#include <errno.h>
        -:   39:#include <fcntl.h>
        -:   40:#include <sys/types.h>
        -:   41:#include <time.h>
        -:   42:#ifndef _WIN32
        -:   43:#include <netdb.h>
        -:   44:#endif
        -:   45:#include <stdio.h>
        -:   46:#include <stdlib.h>
        -:   47:
        -:   48:#include <algorithm>
        -:   49:
        -:   50:#include "my_compiler.h"
        -:   51:#include "my_dbug.h"
        -:   52:#include "my_inttypes.h"
        -:   53:#include "my_io.h"
        -:   54:#include "my_macros.h"
        -:   55:#include "template_utils.h"
        -:   56:#include "vio/vio_priv.h"
        -:   57:
        -:   58:#ifdef FIONREAD_IN_SYS_FILIO
        -:   59:#include <sys/filio.h>
        -:   60:#endif
        -:   61:#ifndef _WIN32
        -:   62:#include <netinet/tcp.h>
        -:   63:#endif
        -:   64:#ifdef HAVE_POLL_H
        -:   65:#include <poll.h>
        -:   66:#endif
        -:   67:#ifdef HAVE_SYS_IOCTL_H
        -:   68:#include <sys/ioctl.h>
        -:   69:#endif
        -:   70:
        -:   71:#include "mysql/psi/mysql_socket.h"
        -:   72:
       14:   73:int vio_errno(Vio *vio [[maybe_unused]]) {
        -:   74:/* These transport types are not Winsock based. */
        -:   75:#ifdef _WIN32
        -:   76:  if (vio->type == VIO_TYPE_NAMEDPIPE || vio->type == VIO_TYPE_SHARED_MEMORY)
        -:   77:    return GetLastError();
        -:   78:#endif
        -:   79:
        -:   80:  /* Mapped to WSAGetLastError() on Win32. */
       14:   81:  return socket_errno;
        -:   82:}
        -:   83:
        -:   84:/**
        -:   85:  Attempt to wait for an I/O event on a socket.
        -:   86:
        -:   87:  @param vio      VIO object representing a connected socket.
        -:   88:  @param event    The type of I/O event (read or write) to wait for.
        -:   89:
        -:   90:  @return Return value is -1 on failure, 0 on success.
        -:   91:*/
        -:   92:
    #####:   93:int vio_socket_io_wait(Vio *vio, enum enum_vio_io_event event) {
        -:   94:  int timeout, ret;
        -:   95:
    #####:   96:  assert(event == VIO_IO_EVENT_READ || event == VIO_IO_EVENT_WRITE);
        -:   97:
        -:   98:  /* Choose an appropriate timeout. */
    #####:   99:  if (event == VIO_IO_EVENT_READ)
    #####:  100:    timeout = vio->read_timeout;
        -:  101:  else
    #####:  102:    timeout = vio->write_timeout;
        -:  103:
        -:  104:  /* Wait for input data to become available. */
    #####:  105:  switch (vio_io_wait(vio, event, timeout)) {
    #####:  106:    case -1:
        -:  107:      /* Upon failure, vio_read/write() shall return -1. */
    #####:  108:      ret = -1;
    #####:  109:      break;
    #####:  110:    case 0:
        -:  111:      /* The wait timed out. */
    #####:  112:      ret = -1;
    #####:  113:      break;
    #####:  114:    default:
        -:  115:      /* A positive value indicates an I/O event. */
    #####:  116:      ret = 0;
    #####:  117:      break;
        -:  118:  }
        -:  119:
    #####:  120:  return ret;
        -:  121:}
        -:  122:
        -:  123:/*
        -:  124:  Define a stub MSG_DONTWAIT if unavailable. In this case, fcntl
        -:  125:  (or a equivalent) is used to enable non-blocking operations.
        -:  126:  The flag must be supported in both send and recv operations.
        -:  127:*/
        -:  128:#if defined(__linux__)
        -:  129:#define VIO_USE_DONTWAIT 1
        -:  130:#define VIO_DONTWAIT MSG_DONTWAIT
        -:  131:#else
        -:  132:#define VIO_DONTWAIT 0
        -:  133:#endif
        -:  134:
    11986:  135:size_t vio_read(Vio *vio, uchar *buf, size_t size) {
        -:  136:  ssize_t ret;
    11986:  137:  int flags = 0;
    23972:  138:  DBUG_TRACE;
        -:  139:
        -:  140:  /* Ensure nobody uses vio_read_buff and vio_read simultaneously. */
   11986*:  141:  assert(vio->read_end == vio->read_pos);
        -:  142:
        -:  143:  /* If timeout is enabled, do not block if data is unavailable. */
   11986*:  144:  if (vio->read_timeout >= 0) flags = VIO_DONTWAIT;
        -:  145:
   11986*:  146:  while ((ret = mysql_socket_recv(vio->mysql_socket, (SOCKBUF_T *)buf, size,
    11986:  147:                                  flags)) == -1) {
    #####:  148:    int error = socket_errno;
        -:  149:
        -:  150:    /* Error encountered that is unrelated to blocking; percolate it up. */
        -:  151:#if SOCKET_EAGAIN == SOCKET_EWOULDBLOCK
    #####:  152:    if (error != SOCKET_EAGAIN)
        -:  153:#else
        -:  154:    if (error != SOCKET_EAGAIN && error != SOCKET_EWOULDBLOCK)
        -:  155:#endif
    #####:  156:      break;
        -:  157:    /*
        -:  158:      Nonblocking with either EAGAIN or EWOULDBLOCK. Don't call
        -:  159:      io_wait. 0 bytes are available.
        -:  160:    */
    #####:  161:    assert(error == SOCKET_EAGAIN || error == SOCKET_EWOULDBLOCK);
    #####:  162:    if (!vio_is_blocking(vio)) {
    #####:  163:      DBUG_PRINT("info", ("vio_read on nonblocking socket read no bytes"));
    #####:  164:      return -1;
        -:  165:    }
        -:  166:
        -:  167:    /* Wait for input data to become available. */
    #####:  168:    if ((ret = vio_socket_io_wait(vio, VIO_IO_EVENT_READ))) break;
        -:  169:  }
    11986:  170:  return ret;
        -:  171:}
        -:  172:
        -:  173:/*
        -:  174:  Buffered read: if average read size is small it may
        -:  175:  reduce number of syscalls.
        -:  176:*/
        -:  177:
   103874:  178:size_t vio_read_buff(Vio *vio, uchar *buf, size_t size) {
        -:  179:  size_t rc;
        -:  180:#define VIO_UNBUFFERED_READ_MIN_SIZE 2048
   103874:  181:  DBUG_TRACE;
  103874*:  182:  DBUG_PRINT("enter", ("sd: %d  buf: %p  size: %u",
        -:  183:                       mysql_socket_getfd(vio->mysql_socket), buf, (uint)size));
        -:  184:
   103874:  185:  if (vio->read_pos < vio->read_end) {
    91888:  186:    rc = std::min<size_t>(vio->read_end - vio->read_pos, size);
    91888:  187:    memcpy(buf, vio->read_pos, rc);
    91888:  188:    vio->read_pos += rc;
        -:  189:    /*
        -:  190:      Do not try to read from the socket now even if rc < size:
        -:  191:      vio_read can return -1 due to an error or non-blocking mode, and
        -:  192:      the safest way to handle it is to move to a separate branch.
        -:  193:    */
    11986:  194:  } else if (size < VIO_UNBUFFERED_READ_MIN_SIZE) {
    11940:  195:    rc = vio_read(vio, (uchar *)vio->read_buffer, VIO_READ_BUFFER_SIZE);
    11940:  196:    if (rc != 0 && rc != (size_t)-1) {
    11940:  197:      if (rc > size) {
    11940:  198:        vio->read_pos = vio->read_buffer + size;
    11940:  199:        vio->read_end = vio->read_buffer + rc;
    11940:  200:        rc = size;
        -:  201:      }
    11940:  202:      memcpy(buf, vio->read_buffer, rc);
        -:  203:    }
        -:  204:  } else
       46:  205:    rc = vio_read(vio, buf, size);
   207748:  206:  return rc;
        -:  207:#undef VIO_UNBUFFERED_READ_MIN_SIZE
        -:  208:}
        -:  209:
    #####:  210:bool vio_buff_has_data(Vio *vio) { return (vio->read_pos != vio->read_end); }
        -:  211:
    11837:  212:size_t vio_write(Vio *vio, const uchar *buf, size_t size) {
        -:  213:  ssize_t ret;
    11837:  214:  int flags = 0;
    23674:  215:  DBUG_TRACE;
        -:  216:
        -:  217:  /* If timeout is enabled, do not block. */
   11837*:  218:  if (vio->write_timeout >= 0) flags = VIO_DONTWAIT;
        -:  219:
   11837*:  220:  while ((ret = mysql_socket_send(vio->mysql_socket,
        -:  221:                                  pointer_cast<const SOCKBUF_T *>(buf), size,
    11837:  222:                                  flags)) == -1) {
    #####:  223:    int error = socket_errno;
        -:  224:
        -:  225:    /* The operation would block? */
        -:  226:#if SOCKET_EAGAIN == SOCKET_EWOULDBLOCK
    #####:  227:    if (error != SOCKET_EAGAIN)
        -:  228:#else
        -:  229:    if (error != SOCKET_EAGAIN && error != SOCKET_EWOULDBLOCK)
        -:  230:#endif
    #####:  231:      break;
        -:  232:
    #####:  233:    if (!vio_is_blocking(vio)) {
    #####:  234:      DBUG_PRINT("info", ("vio_write on nonblocking socket written no bytes"));
    #####:  235:      return -1;
        -:  236:    }
        -:  237:
        -:  238:    /* Wait for the output buffer to become writable.*/
    #####:  239:    if ((ret = vio_socket_io_wait(vio, VIO_IO_EVENT_WRITE))) break;
        -:  240:  }
        -:  241:
    11837:  242:  return ret;
        -:  243:}
        -:  244:
        -:  245:// WL#4896: Not covered
       34:  246:int vio_set_blocking(Vio *vio, bool status) {
       68:  247:  DBUG_TRACE;
        -:  248:
        -:  249:#ifdef _WIN32
        -:  250:
        -:  251:  {
        -:  252:    int ret;
        -:  253:    u_long arg = status ? 0 : 1;
        -:  254:    ret = ioctlsocket(mysql_socket_getfd(vio->mysql_socket), FIONBIO, &arg);
        -:  255:    return ret;
        -:  256:  }
        -:  257:#else
        -:  258:  {
        -:  259:    int flags;
        -:  260:
       34:  261:    if ((flags = fcntl(mysql_socket_getfd(vio->mysql_socket), F_GETFL, NULL)) <
        -:  262:        0)
    #####:  263:      return -1;
        -:  264:
        -:  265:    /*
        -:  266:      Always set/clear the flag to avoid inheritance issues. This is
        -:  267:      a issue mainly on Mac OS X Tiger (version 10.4) where although
        -:  268:      the O_NONBLOCK flag is inherited from the parent socket, the
        -:  269:      actual non-blocking behavior is not inherited.
        -:  270:    */
       34:  271:    if (status)
       17:  272:      flags &= ~O_NONBLOCK;
        -:  273:    else
       17:  274:      flags |= O_NONBLOCK;
        -:  275:
       34:  276:    if (fcntl(mysql_socket_getfd(vio->mysql_socket), F_SETFL, flags) == -1)
    #####:  277:      return -1;
        -:  278:  }
        -:  279:#endif
        -:  280:
       34:  281:  return 0;
        -:  282:}
        -:  283:
    #####:  284:int vio_set_blocking_flag(Vio *vio, bool status) {
    #####:  285:  DBUG_TRACE;
    #####:  286:  int ret = 0;
        -:  287:  /*
        -:  288:    Asynchronous communication in client is allowed only for below
        -:  289:    types of connections.
        -:  290:  */
    #####:  291:  if (VIO_TYPE_TCPIP == vio->type || VIO_TYPE_SOCKET == vio->type ||
    #####:  292:      VIO_TYPE_SSL == vio->type) {
    #####:  293:    vio->is_blocking_flag = status;
    #####:  294:    ret = vio_set_blocking(vio, status);
        -:  295:  } else {
    #####:  296:    DBUG_PRINT("warning", ("Connection type %d is not supported for "
        -:  297:                           "asynchronous communication protocol",
        -:  298:                           vio->type));
    #####:  299:    ret = -1;
        -:  300:  }
    #####:  301:  return ret;
        -:  302:}
        -:  303:
    75549:  304:bool vio_is_blocking(Vio *vio) {
    75549:  305:  DBUG_TRACE;
   151098:  306:  return vio->is_blocking_flag;
        -:  307:}
        -:  308:
       34:  309:int vio_socket_timeout(Vio *vio, uint which [[maybe_unused]], bool old_mode) {
       34:  310:  int ret = 0;
       34:  311:  DBUG_TRACE;
        -:  312:
        -:  313:#if defined(_WIN32)
        -:  314:  {
        -:  315:    int optname;
        -:  316:    DWORD timeout = 0;
        -:  317:    const char *optval = (const char *)&timeout;
        -:  318:
        -:  319:    /*
        -:  320:      The default socket timeout value is zero, which means an infinite
        -:  321:      timeout. Values less than 500 milliseconds are interpreted to be of
        -:  322:      500 milliseconds. Hence, the VIO behavior for zero timeout, which is
        -:  323:      intended to cause the send or receive operation to fail immediately
        -:  324:      if no data is available, is not supported on WIN32 and neither is
        -:  325:      necessary as it's not possible to set the VIO timeout value to zero.
        -:  326:
        -:  327:      Assert that the VIO timeout is either positive or set to infinite.
        -:  328:    */
        -:  329:    assert(which || vio->read_timeout);
        -:  330:    assert(!which || vio->write_timeout);
        -:  331:
        -:  332:    if (which) {
        -:  333:      optname = SO_SNDTIMEO;
        -:  334:      if (vio->write_timeout > 0) timeout = vio->write_timeout;
        -:  335:    } else {
        -:  336:      optname = SO_RCVTIMEO;
        -:  337:      if (vio->read_timeout > 0) timeout = vio->read_timeout;
        -:  338:    }
        -:  339:
        -:  340:    ret = mysql_socket_setsockopt(vio->mysql_socket, SOL_SOCKET, optname,
        -:  341:                                  optval, sizeof(timeout));
        -:  342:  }
        -:  343:#else
        -:  344:  /*
        -:  345:    The MSG_DONTWAIT trick is not used with SSL sockets as the send and
        -:  346:    receive I/O operations are wrapped through SSL-specific functions
        -:  347:    (SSL_read and SSL_write) which are not equivalent to the standard
        -:  348:    recv(2) and send(2) used in vio_read() and vio_write(). Hence, the
        -:  349:    socket blocking mode is changed and vio_io_wait() is used to wait
        -:  350:    for I/O or timeout.
        -:  351:  */
        -:  352:#ifdef VIO_USE_DONTWAIT
       34:  353:  if (vio->type == VIO_TYPE_SSL)
        -:  354:#endif
        -:  355:  {
        -:  356:    /* Deduce what should be the new blocking mode of the socket. */
    #####:  357:    bool new_mode = vio->write_timeout < 0 && vio->read_timeout < 0;
        -:  358:
        -:  359:    /* If necessary, update the blocking mode. */
    #####:  360:    if (new_mode != old_mode) ret = vio_set_blocking(vio, new_mode);
        -:  361:  }
        -:  362:#endif
        -:  363:
       68:  364:  return ret;
        -:  365:}
        -:  366:
       17:  367:int vio_fastsend(Vio *vio) {
       17:  368:  int r = 0;
       17:  369:  DBUG_TRACE;
        -:  370:
        -:  371:#if defined(IPTOS_THROUGHPUT)
        -:  372:  {
        -:  373:    int tos = IPTOS_THROUGHPUT;
        -:  374:    r = mysql_socket_setsockopt(vio->mysql_socket, IPPROTO_IP, IP_TOS,
        -:  375:                                (void *)&tos, sizeof(tos));
        -:  376:  }
        -:  377:#endif /* IPTOS_THROUGHPUT */
       17:  378:  if (!r) {
        -:  379:#ifdef _WIN32
        -:  380:    BOOL nodelay = 1;
        -:  381:#else
       17:  382:    int nodelay = 1;
        -:  383:#endif
        -:  384:
       17:  385:    r = mysql_socket_setsockopt(vio->mysql_socket, IPPROTO_TCP, TCP_NODELAY,
        -:  386:                                IF_WIN((const char *), (void *)) & nodelay,
        -:  387:                                sizeof(nodelay));
        -:  388:  }
       17:  389:  if (r) {
       3*:  390:    DBUG_PRINT("warning", ("Couldn't set socket option for fast send"));
        3:  391:    r = -1;
        -:  392:  }
      17*:  393:  DBUG_PRINT("exit", ("%d", r));
       34:  394:  return r;
        -:  395:}
        -:  396:
       17:  397:int vio_keepalive(Vio *vio, bool set_keep_alive) {
       17:  398:  int r = 0;
       17:  399:  uint opt = 0;
       17:  400:  DBUG_TRACE;
      17*:  401:  DBUG_PRINT("enter",
        -:  402:             ("sd: %d  set_keep_alive: %d",
        -:  403:              mysql_socket_getfd(vio->mysql_socket), (int)set_keep_alive));
       17:  404:  if (vio->type != VIO_TYPE_NAMEDPIPE) {
       17:  405:    if (set_keep_alive) opt = 1;
       17:  406:    r = mysql_socket_setsockopt(vio->mysql_socket, SOL_SOCKET, SO_KEEPALIVE,
        -:  407:                                (char *)&opt, sizeof(opt));
        -:  408:  }
       34:  409:  return r;
        -:  410:}
        -:  411:
        -:  412:/**
        -:  413:  Indicate whether a I/O operation must be retried later.
        -:  414:
        -:  415:  @param vio  A VIO object
        -:  416:
        -:  417:  @return Whether a I/O operation should be deferred.
        -:  418:  @retval true    Temporary failure, retry operation.
        -:  419:  @retval false   Indeterminate failure.
        -:  420:*/
        -:  421:
       14:  422:bool vio_should_retry(Vio *vio) { return (vio_errno(vio) == SOCKET_EINTR); }
        -:  423:
        -:  424:/**
        -:  425:  Indicate whether a I/O operation timed out.
        -:  426:
        -:  427:  @param vio  A VIO object
        -:  428:
        -:  429:  @return Whether a I/O operation timed out.
        -:  430:  @retval true    Operation timed out.
        -:  431:  @retval false   Not a timeout failure.
        -:  432:*/
        -:  433:
    #####:  434:bool vio_was_timeout(Vio *vio) { return (vio_errno(vio) == SOCKET_ETIMEDOUT); }
        -:  435:
        -:  436:#ifdef USE_PPOLL_IN_VIO
    #####:  437:static void vio_wait_until_woken(Vio *vio) {
    #####:  438:  while (vio->poll_shutdown_flag.test_and_set()) {
        -:  439:    // Wait until the vio is woken up from poll.
        -:  440:  }
    #####:  441:}
        -:  442:#elif defined HAVE_KQUEUE
        -:  443:static const int WAKEUP_EVENT_ID = 0xFACEFEED;
        -:  444:
        -:  445:static void vio_wait_until_woken(Vio *vio) {
        -:  446:  if (vio->kq_fd != -1) {
        -:  447:    struct kevent kev;
        -:  448:
        -:  449:    EV_SET(&kev, WAKEUP_EVENT_ID, EVFILT_USER, 0, NOTE_TRIGGER, 0, NULL);
        -:  450:    int nev = kevent(vio->kq_fd, &kev, 1, nullptr, 0, nullptr);
        -:  451:    if (nev != -1) {
        -:  452:      while (vio->kevent_wakeup_flag.test_and_set()) {
        -:  453:        // Wait until the vio is woken up from kevent.
        -:  454:      }
        -:  455:    }
        -:  456:  }
        -:  457:}
        -:  458:#endif
        -:  459:
       17:  460:int vio_shutdown(Vio *vio) {
       17:  461:  int r = 0;
       17:  462:  DBUG_TRACE;
        -:  463:
       17:  464:  if (vio->inactive == false) {
      17*:  465:    assert(vio->type == VIO_TYPE_TCPIP || vio->type == VIO_TYPE_SOCKET ||
        -:  466:           vio->type == VIO_TYPE_SSL);
        -:  467:
      17*:  468:    assert(mysql_socket_getfd(vio->mysql_socket) >= 0);
      17*:  469:    if (mysql_socket_shutdown(vio->mysql_socket, SHUT_RDWR)) r = -1;
        -:  470:
        -:  471:#ifdef USE_PPOLL_IN_VIO
      17*:  472:    if (vio->thread_id != 0 && vio->poll_shutdown_flag.test_and_set()) {
        -:  473:      // Send signal to wake up from poll.
    #####:  474:      if (pthread_kill(vio->thread_id, SIGALRM) == 0)
    #####:  475:        vio_wait_until_woken(vio);
        -:  476:      else
    #####:  477:        perror("Error in pthread_kill");
        -:  478:    }
        -:  479:#elif defined HAVE_KQUEUE
        -:  480:    if (vio->kq_fd != -1 && vio->kevent_wakeup_flag.test_and_set())
        -:  481:      vio_wait_until_woken(vio);
        -:  482:#endif
        -:  483:
      17*:  484:    if (mysql_socket_close(vio->mysql_socket)) r = -1;
        -:  485:#ifdef HAVE_KQUEUE
        -:  486:    if (vio->kq_fd == -1 || close(vio->kq_fd)) r = -1;
        -:  487:    vio->kq_fd = -1;
        -:  488:#endif
        -:  489:  }
        -:  490:
       17:  491:  if (r) {
    #####:  492:    DBUG_PRINT("vio_error", ("close() failed, error: %d", socket_errno));
        -:  493:    /* FIXME: error handling (not critical for MySQL) */
        -:  494:  }
       17:  495:  vio->inactive = true;
       17:  496:  vio->mysql_socket = MYSQL_INVALID_SOCKET;
       34:  497:  return r;
        -:  498:}
        -:  499:
        -:  500:#ifndef NDEBUG
       17:  501:void vio_description(Vio *vio, char *buf) {
       17:  502:  switch (vio->type) {
        3:  503:    case VIO_TYPE_SOCKET:
        3:  504:      snprintf(buf, VIO_DESCRIPTION_SIZE, "socket (%d)",
        -:  505:               mysql_socket_getfd(vio->mysql_socket));
        3:  506:      break;
        -:  507:#ifdef _WIN32
        -:  508:    case VIO_TYPE_NAMEDPIPE:
        -:  509:      my_stpcpy(buf, "named pipe");
        -:  510:      break;
        -:  511:    case VIO_TYPE_SHARED_MEMORY:
        -:  512:      my_stpcpy(buf, "shared memory");
        -:  513:      break;
        -:  514:#endif
       14:  515:    default:
       14:  516:      snprintf(buf, VIO_DESCRIPTION_SIZE, "TCP/IP (%d)",
        -:  517:               mysql_socket_getfd(vio->mysql_socket));
       14:  518:      break;
        -:  519:  }
       17:  520:}
        -:  521:#endif  // NDEBUG
        -:  522:
    #####:  523:enum enum_vio_type vio_type(const Vio *vio) { return vio->type; }
        -:  524:
       17:  525:my_socket vio_fd(Vio *vio) { return mysql_socket_getfd(vio->mysql_socket); }
        -:  526:
        -:  527:/**
        -:  528:  Convert a sock-address (AF_INET or AF_INET6) into the "normalized" form,
        -:  529:  which is the IPv4 form for IPv4-mapped or IPv4-compatible IPv6 addresses.
        -:  530:
        -:  531:  @note Background: when IPv4 and IPv6 are used simultaneously, IPv4
        -:  532:  addresses may be written in a form of IPv4-mapped or IPv4-compatible IPv6
        -:  533:  addresses. That means, one address (a.b.c.d) can be written in three forms:
        -:  534:    - IPv4: a.b.c.d;
        -:  535:    - IPv4-compatible IPv6: @code ::a.b.c.d @endcode;
        -:  536:    - IPv4-mapped IPv4: @code ::ffff:a.b.c.d @endcode;
        -:  537:
        -:  538:  Having three forms of one address makes it a little difficult to compare
        -:  539:  addresses with each other (the IPv4-compatible IPv6-address of foo.bar
        -:  540:  will be different from the IPv4-mapped IPv6-address of foo.bar).
        -:  541:
        -:  542:  @note This function can be made public when it's needed.
        -:  543:
        -:  544:  @param [in] src         source IP address (AF_INET or AF_INET6).
        -:  545:  @param [in] src_length  length of the src.
        -:  546:  @param [out] dst        a buffer to store normalized IP address
        -:  547:                          (sockaddr_storage).
        -:  548:  @param [out] dst_length actual length of the normalized IP address.
        -:  549:*/
    #####:  550:static void vio_get_normalized_ip(const struct sockaddr *src, size_t src_length,
        -:  551:                                  struct sockaddr *dst, size_t *dst_length) {
    #####:  552:  switch (src->sa_family) {
    #####:  553:    case AF_INET:
    #####:  554:      memcpy(dst, src, src_length);
    #####:  555:      *dst_length = src_length;
    #####:  556:      break;
        -:  557:
    #####:  558:    case AF_INET6: {
    #####:  559:      const struct sockaddr_in6 *src_addr6 = (const struct sockaddr_in6 *)src;
    #####:  560:      const struct in6_addr *src_ip6 = &(src_addr6->sin6_addr);
        -:  561:      const uint32 *src_ip6_int32 =
    #####:  562:          pointer_cast<const uint32 *>(src_ip6->s6_addr);
        -:  563:
    #####:  564:      if (IN6_IS_ADDR_V4MAPPED(src_ip6) || IN6_IS_ADDR_V4COMPAT(src_ip6)) {
    #####:  565:        struct sockaddr_in *dst_ip4 = (struct sockaddr_in *)dst;
        -:  566:
        -:  567:        /*
        -:  568:          This is an IPv4-mapped or IPv4-compatible IPv6 address. It should
        -:  569:          be converted to the IPv4 form.
        -:  570:        */
        -:  571:
    #####:  572:        *dst_length = sizeof(struct sockaddr_in);
        -:  573:
    #####:  574:        memset(dst_ip4, 0, *dst_length);
    #####:  575:        dst_ip4->sin_family = AF_INET;
    #####:  576:        dst_ip4->sin_port = src_addr6->sin6_port;
        -:  577:
        -:  578:        /*
        -:  579:          In an IPv4 mapped or compatible address, the last 32 bits represent
        -:  580:          the IPv4 address. The byte orders for IPv6 and IPv4 addresses are
        -:  581:          the same, so a simple copy is possible.
        -:  582:        */
    #####:  583:        dst_ip4->sin_addr.s_addr = src_ip6_int32[3];
        -:  584:      } else {
        -:  585:        /* This is a "native" IPv6 address. */
        -:  586:
    #####:  587:        memcpy(dst, src, src_length);
    #####:  588:        *dst_length = src_length;
        -:  589:      }
        -:  590:
    #####:  591:      break;
        -:  592:    }
        -:  593:  }
    #####:  594:}
        -:  595:
        -:  596:/**
        -:  597:  Return the normalized IP address string for a sock-address.
        -:  598:
        -:  599:  The idea is to return an IPv4-address for an IPv4-mapped and
        -:  600:  IPv4-compatible IPv6 address.
        -:  601:
        -:  602:  The function writes the normalized IP address to the given buffer.
        -:  603:  The buffer should have enough space, otherwise error flag is returned.
        -:  604:  The system constant INET6_ADDRSTRLEN can be used to reserve buffers of
        -:  605:  the right size.
        -:  606:
        -:  607:  @param [in] addr            sockaddr object (AF_INET or AF_INET6).
        -:  608:  @param [in] addr_length     length of the addr.
        -:  609:  @param [out] ip_string      buffer to write normalized IP address.
        -:  610:  @param [in] ip_string_size  size of the ip_string.
        -:  611:
        -:  612:  @return Error status.
        -:  613:  @retval true in case of error (the ip_string buffer is not enough).
        -:  614:  @retval false on success.
        -:  615:*/
        -:  616:
    #####:  617:bool vio_get_normalized_ip_string(const struct sockaddr *addr,
        -:  618:                                  size_t addr_length, char *ip_string,
        -:  619:                                  size_t ip_string_size) {
        -:  620:  struct sockaddr_storage norm_addr_storage;
    #####:  621:  struct sockaddr *norm_addr = (struct sockaddr *)&norm_addr_storage;
        -:  622:  size_t norm_addr_length;
        -:  623:  int err_code;
        -:  624:
    #####:  625:  vio_get_normalized_ip(addr, addr_length, norm_addr, &norm_addr_length);
        -:  626:
    #####:  627:  err_code = vio_getnameinfo(norm_addr, ip_string, ip_string_size, nullptr, 0,
        -:  628:                             NI_NUMERICHOST);
        -:  629:
    #####:  630:  if (!err_code) return false;
        -:  631:
    #####:  632:  DBUG_PRINT("error", ("getnameinfo() failed with %d (%s).", (int)err_code,
        -:  633:                       (const char *)gai_strerror(err_code)));
    #####:  634:  return true;
        -:  635:}
        -:  636:
        -:  637:/**
        -:  638:  Return IP address and port of a VIO client socket.
        -:  639:
        -:  640:  The function returns an IPv4 address if IPv6 support is disabled.
        -:  641:
        -:  642:  The function returns an IPv4 address if the client socket is associated
        -:  643:  with an IPv4-compatible or IPv4-mapped IPv6 address. Otherwise, the native
        -:  644:  IPv6 address is returned.
        -:  645:*/
        -:  646:
    #####:  647:bool vio_peer_addr(Vio *vio, char *ip_buffer, uint16 *port,
        -:  648:                   size_t ip_buffer_size) {
    #####:  649:  DBUG_TRACE;
    #####:  650:  DBUG_PRINT("enter", ("Client socked fd: %d",
        -:  651:                       (int)mysql_socket_getfd(vio->mysql_socket)));
        -:  652:
    #####:  653:  if (vio->localhost) {
        -:  654:    /*
        -:  655:      Initialize vio->remote and vio->addLen. Set vio->remote to IPv4 loopback
        -:  656:      address.
        -:  657:    */
    #####:  658:    struct in_addr *ip4 = &((struct sockaddr_in *)&(vio->remote))->sin_addr;
        -:  659:
    #####:  660:    vio->remote.ss_family = AF_INET;
    #####:  661:    vio->addrLen = sizeof(struct sockaddr_in);
        -:  662:
    #####:  663:    ip4->s_addr = htonl(INADDR_LOOPBACK);
        -:  664:
        -:  665:    /* Initialize ip_buffer and port. */
        -:  666:
    #####:  667:    my_stpcpy(ip_buffer, "127.0.0.1");
    #####:  668:    *port = 0;
        -:  669:  } else {
        -:  670:    int err_code;
        -:  671:    char port_buffer[NI_MAXSERV];
        -:  672:
        -:  673:    struct sockaddr_storage addr_storage;
    #####:  674:    struct sockaddr *addr = (struct sockaddr *)&addr_storage;
    #####:  675:    socket_len_t addr_length = sizeof(addr_storage);
        -:  676:
        -:  677:    /* Get sockaddr by socked fd. */
        -:  678:
    #####:  679:    err_code = mysql_socket_getpeername(vio->mysql_socket, addr, &addr_length);
        -:  680:
    #####:  681:    if (err_code) {
    #####:  682:      DBUG_PRINT("exit", ("getpeername() gave error: %d", socket_errno));
    #####:  683:      return true;
        -:  684:    }
        -:  685:
        -:  686:    /* Normalize IP address. */
        -:  687:
    #####:  688:    vio_get_normalized_ip(addr, addr_length, (struct sockaddr *)&vio->remote,
        -:  689:                          &vio->addrLen);
        -:  690:
        -:  691:    /* Get IP address & port number. */
        -:  692:
    #####:  693:    err_code = vio_getnameinfo((struct sockaddr *)&vio->remote, ip_buffer,
        -:  694:                               ip_buffer_size, port_buffer, NI_MAXSERV,
        -:  695:                               NI_NUMERICHOST | NI_NUMERICSERV);
        -:  696:
    #####:  697:    if (err_code) {
    #####:  698:      DBUG_PRINT("exit",
        -:  699:                 ("getnameinfo() gave error: %s", gai_strerror(err_code)));
    #####:  700:      return true;
        -:  701:    }
        -:  702:
    #####:  703:    *port = (uint16)strtol(port_buffer, nullptr, 10);
        -:  704:  }
        -:  705:
    #####:  706:  DBUG_PRINT("exit", ("Client IP address: %s; port: %d",
        -:  707:                      (const char *)ip_buffer, (int)*port));
    #####:  708:  return false;
        -:  709:}
        -:  710:
        -:  711:/**
        -:  712:  Retrieve the amount of data that can be read from a socket.
        -:  713:
        -:  714:  @param vio          A VIO object.
        -:  715:  @param [out] bytes  The amount of bytes available.
        -:  716:
        -:  717:  @retval false   Success.
        -:  718:  @retval true    Failure.
        -:  719:*/
        -:  720:// WL#4896: Not covered
    #####:  721:static bool socket_peek_read(Vio *vio, uint *bytes) {
    #####:  722:  my_socket sd = mysql_socket_getfd(vio->mysql_socket);
        -:  723:#if defined(_WIN32)
        -:  724:  u_long len;
        -:  725:  if (ioctlsocket(sd, FIONREAD, &len)) return true;
        -:  726:  *bytes = len;
        -:  727:  return false;
        -:  728:#elif defined(FIONREAD_IN_SYS_IOCTL) || defined(FIONREAD_IN_SYS_FILIO)
        -:  729:  int len;
    #####:  730:  if (ioctl(sd, FIONREAD, &len) < 0) return true;
    #####:  731:  *bytes = len;
    #####:  732:  return false;
        -:  733:#else
        -:  734:  char buf[1024];
        -:  735:  ssize_t res = recv(sd, &buf, sizeof(buf), MSG_PEEK);
        -:  736:  if (res < 0) return true;
        -:  737:  *bytes = res;
        -:  738:  return false;
        -:  739:#endif
        -:  740:}
        -:  741:
        -:  742:#ifndef _WIN32
        -:  743:
        -:  744:/**
        -:  745:  Set of event flags grouped by operations.
        -:  746:*/
        -:  747:
        -:  748:/*
        -:  749:  Linux specific flag used to detect connection shutdown. The flag is
        -:  750:  also used for half-closed notification, which here is interpreted as
        -:  751:  if there is data available to be read from the socket.
        -:  752:*/
        -:  753:#ifndef POLLRDHUP
        -:  754:#define POLLRDHUP 0
        -:  755:#endif
        -:  756:
        -:  757:/* Data may be read. */
        -:  758:#define MY_POLL_SET_IN (POLLIN | POLLPRI)
        -:  759:/* Data may be written. */
        -:  760:#define MY_POLL_SET_OUT (POLLOUT)
        -:  761:/* An error or hangup. */
        -:  762:#define MY_POLL_SET_ERR (POLLERR | POLLHUP | POLLNVAL)
        -:  763:
        -:  764:#endif
        -:  765:
        -:  766:/**
        -:  767:  Wait for an I/O event on a VIO socket.
        -:  768:
        -:  769:  @param vio      VIO object representing a connected socket.
        -:  770:  @param event    The type of I/O event to wait for.
        -:  771:  @param timeout  Interval (in milliseconds) to wait for an I/O event.
        -:  772:                  A negative timeout value means an infinite timeout.
        -:  773:
        -:  774:  @remark sock_errno is set to SOCKET_ETIMEDOUT on timeout.
        -:  775:
        -:  776:  @return A three-state value which indicates the operation status.
        -:  777:  @retval -1  Failure, socket_errno indicates the error.
        -:  778:  @retval  0  The wait has timed out.
        -:  779:  @retval  1  The requested I/O event has occurred.
        -:  780:*/
        -:  781:
        -:  782:#if !defined(_WIN32) && !defined(HAVE_KQUEUE)
       31:  783:int vio_io_wait(Vio *vio, enum enum_vio_io_event event, int timeout) {
        -:  784:  int ret;
       31:  785:  int retry_count = 0;
        -:  786:#ifndef NDEBUG
       31:  787:  short revents = 0;
        -:  788:#endif
        -:  789:  struct pollfd pfd;
       31:  790:  my_socket sd = mysql_socket_getfd(vio->mysql_socket);
       31:  791:  MYSQL_SOCKET_WAIT_VARIABLES(locker, state) /* no ';' */
       62:  792:  DBUG_TRACE;
        -:  793:
       31:  794:  memset(&pfd, 0, sizeof(pfd));
        -:  795:
       31:  796:  pfd.fd = sd;
        -:  797:
        -:  798:  /*
        -:  799:    Set the poll bitmask describing the type of events.
        -:  800:    The error flags are only valid in the revents bitmask.
        -:  801:  */
       31:  802:  switch (event) {
       17:  803:    case VIO_IO_EVENT_READ:
       17:  804:      pfd.events = MY_POLL_SET_IN;
        -:  805:#ifndef NDEBUG
       17:  806:      revents = MY_POLL_SET_IN | MY_POLL_SET_ERR | POLLRDHUP;
        -:  807:#endif
       17:  808:      break;
       14:  809:    case VIO_IO_EVENT_WRITE:
        -:  810:    case VIO_IO_EVENT_CONNECT:
       14:  811:      pfd.events = MY_POLL_SET_OUT;
        -:  812:#ifndef NDEBUG
       14:  813:      revents = MY_POLL_SET_OUT | MY_POLL_SET_ERR;
        -:  814:#endif
       14:  815:      break;
        -:  816:  }
        -:  817:
       31:  818:  MYSQL_START_SOCKET_WAIT(locker, &state, vio->mysql_socket, PSI_SOCKET_SELECT,
        -:  819:                          0);
        -:  820:
        -:  821:#ifdef USE_PPOLL_IN_VIO
        -:  822:  // Check if shutdown is in progress, if so return -1
      31*:  823:  if (vio->poll_shutdown_flag.test_and_set()) return -1;
        -:  824:
        -:  825:  timespec ts;
       31:  826:  timespec *ts_ptr = nullptr;
        -:  827:
       31:  828:  if (timeout >= 0) {
       31:  829:    ts = {timeout / 1000, (timeout % 1000) * 1000000};
       31:  830:    ts_ptr = &ts;
        -:  831:  }
        -:  832:#endif
        -:  833:
        -:  834:  /*
        -:  835:    Wait for the I/O event and return early in case of
        -:  836:    error or timeout.
        -:  837:  */
    #####:  838:  do {
        -:  839:#ifdef USE_PPOLL_IN_VIO
        -:  840:    /*
        -:  841:      vio->signal_mask is only useful when thread_id != 0.
        -:  842:      thread_id is only set for servers, so signal_mask is unused for client
        -:  843:      libraries.
        -:  844:    */
      31*:  845:    ret = ppoll(&pfd, 1, ts_ptr,
       31:  846:                vio->thread_id != 0 ? &vio->signal_mask : nullptr);
        -:  847:#else
        -:  848:    ret = poll(&pfd, 1, timeout);
        -:  849:#endif
      31*:  850:  } while (ret < 0 && vio_should_retry(vio) &&
    #####:  851:           (retry_count++ < vio->retry_count));
        -:  852:
        -:  853:#ifdef USE_PPOLL_IN_VIO
       31:  854:  vio->poll_shutdown_flag.clear();
        -:  855:#endif
        -:  856:
       31:  857:  switch (ret) {
    #####:  858:    case -1:
        -:  859:      /* On error, -1 is returned. */
    #####:  860:      break;
    #####:  861:    case 0:
        -:  862:      /*
        -:  863:        Set errno to indicate a timeout error.
        -:  864:        (This is not compiled in on WIN32.)
        -:  865:      */
    #####:  866:      errno = SOCKET_ETIMEDOUT;
    #####:  867:      break;
       31:  868:    default:
        -:  869:      /* Ensure that the requested I/O event has completed. */
      31*:  870:      assert(pfd.revents & revents);
       31:  871:      break;
        -:  872:  }
        -:  873:
       31:  874:  MYSQL_END_SOCKET_WAIT(locker, 0);
       31:  875:  return ret;
        -:  876:}
        -:  877:
        -:  878:#elif defined(_WIN32)
        -:  879:int vio_io_wait(Vio *vio, enum enum_vio_io_event event, int timeout) {
        -:  880:  int ret;
        -:  881:  int retry_count = 0;
        -:  882:  struct timeval tm;
        -:  883:  my_socket fd;
        -:  884:  fd_set readfds, writefds, exceptfds;
        -:  885:  MYSQL_SOCKET_WAIT_VARIABLES(locker, state) /* no ';' */
        -:  886:  DBUG_TRACE;
        -:  887:
        -:  888:  fd = mysql_socket_getfd(vio->mysql_socket);
        -:  889:
        -:  890:  if (fd == INVALID_SOCKET) return -1;
        -:  891:
        -:  892:  /* Convert the timeout, in milliseconds, to seconds and microseconds. */
        -:  893:  if (timeout >= 0) {
        -:  894:    tm.tv_sec = timeout / 1000;
        -:  895:    tm.tv_usec = (timeout % 1000) * 1000;
        -:  896:  }
        -:  897:
        -:  898:  FD_ZERO(&readfds);
        -:  899:  FD_ZERO(&writefds);
        -:  900:  FD_ZERO(&exceptfds);
        -:  901:
        -:  902:  /* Always receive notification of exceptions. */
        -:  903:  FD_SET(fd, &exceptfds);
        -:  904:
        -:  905:  switch (event) {
        -:  906:    case VIO_IO_EVENT_READ:
        -:  907:      /* Readiness for reading. */
        -:  908:      FD_SET(fd, &readfds);
        -:  909:      break;
        -:  910:    case VIO_IO_EVENT_WRITE:
        -:  911:    case VIO_IO_EVENT_CONNECT:
        -:  912:      /* Readiness for writing. */
        -:  913:      FD_SET(fd, &writefds);
        -:  914:      break;
        -:  915:  }
        -:  916:
        -:  917:  MYSQL_START_SOCKET_WAIT(locker, &state, vio->mysql_socket, PSI_SOCKET_SELECT,
        -:  918:                          0);
        -:  919:
        -:  920:  /* The first argument is ignored on Windows. */
        -:  921:  do {
        -:  922:    ret = select((int)(fd + 1), &readfds, &writefds, &exceptfds,
        -:  923:                 (timeout >= 0) ? &tm : NULL);
        -:  924:  } while (ret < 0 && vio_should_retry(vio) &&
        -:  925:           (retry_count++ < vio->retry_count));
        -:  926:
        -:  927:  MYSQL_END_SOCKET_WAIT(locker, 0);
        -:  928:
        -:  929:  /* Set error code to indicate a timeout error. */
        -:  930:  if (ret == 0) WSASetLastError(SOCKET_ETIMEDOUT);
        -:  931:
        -:  932:  /* Error or timeout? */
        -:  933:  if (ret <= 0) return ret;
        -:  934:
        -:  935:  /* The requested I/O event is ready? */
        -:  936:  switch (event) {
        -:  937:    case VIO_IO_EVENT_READ:
        -:  938:      ret = (FD_ISSET(fd, &readfds) ? 1 : 0);
        -:  939:      break;
        -:  940:    case VIO_IO_EVENT_WRITE:
        -:  941:    case VIO_IO_EVENT_CONNECT:
        -:  942:      ret = (FD_ISSET(fd, &writefds) ? 1 : 0);
        -:  943:      break;
        -:  944:  }
        -:  945:
        -:  946:  /* Error conditions pending? */
        -:  947:  ret |= (FD_ISSET(fd, &exceptfds) ? 1 : 0);
        -:  948:
        -:  949:  /* Not a timeout, ensure that a condition was met. */
        -:  950:  assert(ret);
        -:  951:
        -:  952:  return ret;
        -:  953:}
        -:  954:#elif defined(HAVE_KQUEUE)
        -:  955:int vio_io_wait(Vio *vio, enum enum_vio_io_event event, int timeout) {
        -:  956:  int nev;
        -:  957:  static const int MAX_EVENT = 2;
        -:  958:  struct kevent kev_set[MAX_EVENT];
        -:  959:  struct kevent kev_event[MAX_EVENT];
        -:  960:
        -:  961:  my_socket fd = mysql_socket_getfd(vio->mysql_socket);
        -:  962:  MYSQL_SOCKET_WAIT_VARIABLES(locker, state) /* no ';' */
        -:  963:  DBUG_TRACE;
        -:  964:
        -:  965:  if (vio->kq_fd == -1) return -1;
        -:  966:
        -:  967:  EV_SET(&kev_set[1], WAKEUP_EVENT_ID, EVFILT_USER,
        -:  968:         EV_ADD | EV_ENABLE | EV_DISPATCH | EV_CLEAR, 0, 0, nullptr);
        -:  969:  switch (event) {
        -:  970:    case VIO_IO_EVENT_READ:
        -:  971:      EV_SET(&kev_set[0], fd, EVFILT_READ,
        -:  972:             EV_ADD | EV_ENABLE | EV_DISPATCH | EV_CLEAR, 0, 0, nullptr);
        -:  973:      break;
        -:  974:    case VIO_IO_EVENT_WRITE:
        -:  975:    case VIO_IO_EVENT_CONNECT:
        -:  976:      EV_SET(&kev_set[0], fd, EVFILT_WRITE,
        -:  977:             EV_ADD | EV_ENABLE | EV_DISPATCH | EV_CLEAR, 0, 0, nullptr);
        -:  978:      break;
        -:  979:  }
        -:  980:  MYSQL_START_SOCKET_WAIT(locker, &state, vio->mysql_socket, PSI_SOCKET_SELECT,
        -:  981:                          0);
        -:  982:
        -:  983:  timespec ts = {static_cast<long>(timeout / 1000),
        -:  984:                 (static_cast<long>(timeout) % 1000) * 1000000};
        -:  985:
        -:  986:  // Check if shutdown is in progress, if so return -1.
        -:  987:  if (vio->kevent_wakeup_flag.test_and_set()) return -1;
        -:  988:
        -:  989:  int retry_count = 0;
        -:  990:  do {
        -:  991:    nev = kevent(vio->kq_fd, kev_set, MAX_EVENT, kev_event, MAX_EVENT,
        -:  992:                 timeout >= 0 ? &ts : nullptr);
        -:  993:  } while (nev < 0 && vio_should_retry(vio) &&
        -:  994:           (retry_count++ < vio->retry_count));
        -:  995:
        -:  996:  vio->kevent_wakeup_flag.clear();
        -:  997:
        -:  998:  if (nev == -1) {
        -:  999:    // On error, -1 is returned.
        -: 1000:    DBUG_PRINT("error", ("kevent returned error %d\n", errno));
        -: 1001:  } else if (nev == 0) {
        -: 1002:    // Timeout in kevent.
        -: 1003:    errno = SOCKET_ETIMEDOUT;
        -: 1004:  } else {
        -: 1005:    for (int i = 0; i < nev; i++) {
        -: 1006:      if (!(kev_event[i].flags & (EV_ERROR | EV_EOF))) {
        -: 1007:        // Ensure that the requested I/O event has completed.
        -: 1008:        assert(event == VIO_IO_EVENT_READ ? kev_event[i].filter & EVFILT_READ
        -: 1009:                                          : kev_event[i].filter & EVFILT_WRITE);
        -: 1010:      }
        -: 1011:
        -: 1012:      // Shutdown or kill in progress, indicate error.
        -: 1013:      if (kev_event[i].filter == EVFILT_USER) {
        -: 1014:        nev = -1;
        -: 1015:        break;
        -: 1016:      }
        -: 1017:    }
        -: 1018:  }
        -: 1019:
        -: 1020:  MYSQL_END_SOCKET_WAIT(locker, 0);
        -: 1021:  return nev;
        -: 1022:}
        -: 1023:#endif  // HAVE_KQUEUE
        -: 1024:
        -: 1025:/**
        -: 1026:  Connect to a peer address.
        -: 1027:
        -: 1028:  @param vio       A VIO object.
        -: 1029:  @param addr      Socket address containing the peer address.
        -: 1030:  @param len       Length of socket address.
        -: 1031:  @param nonblocking flag to represent if socket is blocking or nonblocking
        -: 1032:  @param timeout   Interval (in milliseconds) to wait until a
        -: 1033:                   connection is established.
        -: 1034:  @param [out] connect_done Indication if connect actually completed or not.
        -: 1035:                   If set to true this means there's no need to wait for
        -: 1036:                   connect to complete anymore.
        -: 1037:
        -: 1038:  @retval false   A connection was successfully established.
        -: 1039:  @retval true    A fatal error. See socket_errno.
        -: 1040:*/
        -: 1041:
       17: 1042:bool vio_socket_connect(Vio *vio, struct sockaddr *addr, socklen_t len,
        -: 1043:                        bool nonblocking, int timeout, bool *connect_done) {
        -: 1044:  int ret, wait;
       17: 1045:  int retry_count = 0;
       34: 1046:  DBUG_TRACE;
        -: 1047:
        -: 1048:  /* Only for socket-based transport types. */
      17*: 1049:  assert(vio->type == VIO_TYPE_SOCKET || vio->type == VIO_TYPE_TCPIP);
        -: 1050:
        -: 1051:  /* If timeout is not infinite, set socket to non-blocking mode. */
      17*: 1052:  if (((timeout > -1) || nonblocking) && vio_set_blocking(vio, false))
    #####: 1053:    return true;
        -: 1054:
        -: 1055:  /* Initiate the connection. */
    #####: 1056:  do {
       17: 1057:    ret = mysql_socket_connect(vio->mysql_socket, addr, len);
      17*: 1058:  } while (ret < 0 && vio_should_retry(vio) &&
    #####: 1059:           (retry_count++ < vio->retry_count));
        -: 1060:
       17: 1061:  if (connect_done) *connect_done = (ret == 0);
        -: 1062:
        -: 1063:#ifdef _WIN32
        -: 1064:  wait = (ret == SOCKET_ERROR) && (WSAGetLastError() == WSAEINPROGRESS ||
        -: 1065:                                   WSAGetLastError() == WSAEWOULDBLOCK);
        -: 1066:#else
      17*: 1067:  wait = (ret == -1) && (errno == EINPROGRESS || errno == EALREADY);
        -: 1068:#endif
        -: 1069:
        -: 1070:  /*
        -: 1071:    The connection is in progress. The vio_io_wait() call can be used
        -: 1072:    to wait up to a specified period of time for the connection to
        -: 1073:    succeed.
        -: 1074:
        -: 1075:    If vio_io_wait() returns 0 (after waiting however many seconds),
        -: 1076:    the socket never became writable (host is probably unreachable.)
        -: 1077:    Otherwise, if vio_io_wait() returns 1, then one of two conditions
        -: 1078:    exist:
        -: 1079:
        -: 1080:    1. An error occurred. Use getsockopt() to check for this.
        -: 1081:    2. The connection was set up successfully: getsockopt() will
        -: 1082:       return 0 as an error.
        -: 1083:  */
       31: 1084:  if (!nonblocking && wait &&
       14: 1085:      (vio_io_wait(vio, VIO_IO_EVENT_CONNECT, timeout) == 1)) {
        -: 1086:    int error;
       14: 1087:    IF_WIN(int, socklen_t) optlen = sizeof(error);
       14: 1088:    IF_WIN(char, void) *optval = (IF_WIN(char, void) *)&error;
        -: 1089:
        -: 1090:    /*
        -: 1091:      At this point, we know that something happened on the socket.
        -: 1092:      But this does not means that everything is alright. The connect
        -: 1093:      might have failed. We need to retrieve the error code from the
        -: 1094:      socket layer. We must return success only if we are sure that
        -: 1095:      it was really a success. Otherwise we might prevent the caller
        -: 1096:      from trying another address to connect to.
        -: 1097:    */
       14: 1098:    if (connect_done) *connect_done = true;
       14: 1099:    if (!(ret = mysql_socket_getsockopt(vio->mysql_socket, SOL_SOCKET, SO_ERROR,
        -: 1100:                                        optval, &optlen))) {
        -: 1101:#ifdef _WIN32
        -: 1102:      WSASetLastError(error);
        -: 1103:#else
       14: 1104:      errno = error;
        -: 1105:#endif
       14: 1106:      ret = (error != 0);
        -: 1107:    }
        -: 1108:  }
        -: 1109:
        -: 1110:  /* If necessary, restore the blocking mode, but only if connect succeeded. */
       17: 1111:  if (!nonblocking && (timeout > -1) && (ret == 0)) {
      17*: 1112:    if (vio_set_blocking(vio, true)) return true;
        -: 1113:  }
        -: 1114:
      17*: 1115:  if (nonblocking && wait) {
    #####: 1116:    if (connect_done) *connect_done = false;
    #####: 1117:    return false;
        -: 1118:  } else {
       17: 1119:    return (ret != 0);
        -: 1120:  }
        -: 1121:}
        -: 1122:
        -: 1123:/**
        -: 1124:  Determine if the endpoint of a connection is still available.
        -: 1125:
        -: 1126:  @remark The socket is assumed to be disconnected if an EOF
        -: 1127:          condition is encountered.
        -: 1128:
        -: 1129:  @param vio      The VIO object.
        -: 1130:
        -: 1131:  @retval true    EOF condition not found.
        -: 1132:  @retval false   EOF condition is signaled.
        -: 1133:*/
        -: 1134:
    #####: 1135:bool vio_is_connected(Vio *vio) {
    #####: 1136:  uint bytes = 0;
    #####: 1137:  DBUG_TRACE;
        -: 1138:
        -: 1139:  /*
        -: 1140:    The first step of detecting an EOF condition is verifying
        -: 1141:    whether there is data to read. Data in this case would be
        -: 1142:    the EOF. An exceptional condition event and/or errors are
        -: 1143:    interpreted as if there is data to read.
        -: 1144:  */
    #####: 1145:  if (!vio_io_wait(vio, VIO_IO_EVENT_READ, 0)) return true;
        -: 1146:
        -: 1147:  /*
        -: 1148:    The second step is read() or recv() from the socket returning
        -: 1149:    0 (EOF). Unfortunately, it's not possible to call read directly
        -: 1150:    as we could inadvertently read meaningful connection data.
        -: 1151:    Simulate a read by retrieving the number of bytes available to
        -: 1152:    read -- 0 meaning EOF. In the presence of unrecoverable errors,
        -: 1153:    the socket is assumed to be disconnected.
        -: 1154:  */
    #####: 1155:  while (socket_peek_read(vio, &bytes)) {
    #####: 1156:    if (socket_errno != SOCKET_EINTR) return false;
        -: 1157:  }
        -: 1158:
        -: 1159:  /* There might be buffered data at the SSL layer. */
    #####: 1160:  if (!bytes && vio->type == VIO_TYPE_SSL)
    #####: 1161:    bytes = SSL_pending((SSL *)vio->ssl_arg);
        -: 1162:
    #####: 1163:  return bytes ? true : false;
        -: 1164:}
        -: 1165:
        -: 1166:#ifndef NDEBUG
        -: 1167:
        -: 1168:/**
        -: 1169:  Number of bytes in the read or socket buffer
        -: 1170:
        -: 1171:  @remark An EOF condition might count as one readable byte.
        -: 1172:
        -: 1173:  @return number of bytes in one of the buffers or < 0 if error.
        -: 1174:*/
        -: 1175:
    #####: 1176:ssize_t vio_pending(Vio *vio) {
    #####: 1177:  uint bytes = 0;
        -: 1178:
        -: 1179:  /* Data pending on the read buffer. */
    #####: 1180:  if (vio->read_pos < vio->read_end) return vio->read_end - vio->read_pos;
        -: 1181:
        -: 1182:  /* Skip non-socket based transport types. */
    #####: 1183:  if (vio->type == VIO_TYPE_TCPIP || vio->type == VIO_TYPE_SOCKET) {
        -: 1184:    /* Obtain number of readable bytes in the socket buffer. */
    #####: 1185:    if (socket_peek_read(vio, &bytes)) return -1;
        -: 1186:  }
        -: 1187:
    #####: 1188:  return (ssize_t)bytes;
        -: 1189:}
        -: 1190:
        -: 1191:#endif
        -: 1192:
        -: 1193:/**
        -: 1194:  Checks if the error code, returned by vio_getnameinfo(), means it was the
        -: 1195:  "No-name" error.
        -: 1196:
        -: 1197:  Windows-specific note: getnameinfo() returns WSANO_DATA instead of
        -: 1198:  EAI_NODATA or EAI_NONAME when no reverse mapping is available at the host
        -: 1199:  (i.e. Windows can't get hostname by IP-address). This error should be
        -: 1200:  treated as EAI_NONAME.
        -: 1201:
        -: 1202:  @return if the error code is actually EAI_NONAME.
        -: 1203:  @retval true if the error code is EAI_NONAME.
        -: 1204:  @retval false otherwise.
        -: 1205:*/
        -: 1206:
    #####: 1207:bool vio_is_no_name_error(int err_code) {
        -: 1208:#ifdef _WIN32
        -: 1209:
        -: 1210:  return err_code == WSANO_DATA || err_code == EAI_NONAME;
        -: 1211:
        -: 1212:#else
        -: 1213:
    #####: 1214:  return err_code == EAI_NONAME;
        -: 1215:
        -: 1216:#endif
        -: 1217:}
        -: 1218:
        -: 1219:/**
        -: 1220:  This is a wrapper for the system getnameinfo(), because different OS
        -: 1221:  differ in the getnameinfo() implementation:
        -: 1222:    - Solaris 10 requires that the 2nd argument (salen) must match the
        -: 1223:      actual size of the struct sockaddr_storage passed to it;
        -: 1224:    - Mac OS X has sockaddr_in::sin_len and sockaddr_in6::sin6_len and
        -: 1225:      requires them to be filled.
        -: 1226:*/
        -: 1227:
    #####: 1228:int vio_getnameinfo(const struct sockaddr *sa, char *hostname,
        -: 1229:                    size_t hostname_size, char *port, size_t port_size,
        -: 1230:                    int flags) {
    #####: 1231:  int sa_length = 0;
        -: 1232:
    #####: 1233:  switch (sa->sa_family) {
    #####: 1234:    case AF_INET:
    #####: 1235:      sa_length = sizeof(struct sockaddr_in);
        -: 1236:#ifdef HAVE_SOCKADDR_IN_SIN_LEN
        -: 1237:      ((struct sockaddr_in *)sa)->sin_len = sa_length;
        -: 1238:#endif /* HAVE_SOCKADDR_IN_SIN_LEN */
    #####: 1239:      break;
        -: 1240:
    #####: 1241:    case AF_INET6:
    #####: 1242:      sa_length = sizeof(struct sockaddr_in6);
        -: 1243:#ifdef HAVE_SOCKADDR_IN6_SIN6_LEN
        -: 1244:      ((struct sockaddr_in6 *)sa)->sin6_len = sa_length;
        -: 1245:#endif /* HAVE_SOCKADDR_IN6_SIN6_LEN */
    #####: 1246:      break;
        -: 1247:  }
        -: 1248:
    #####: 1249:  return getnameinfo(sa, sa_length, hostname, hostname_size, port, port_size,
    #####: 1250:                     flags);
        -: 1251:}
