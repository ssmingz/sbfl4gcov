        -:    0:Source:/mnt/hwshare/gcov_mysql/mysql_9_dfb4f427442f5fc4112a4847c09e1c51e420077c_pre/include/m_string.h
        -:    0:Graph:viosslfactories.cc.gcno
        -:    0:Data:viosslfactories.cc.gcda
        -:    0:Runs:4
        -:    0:Programs:2
        -:    1:/*
        -:    2:   Copyright (c) 2000, 2021, Oracle and/or its affiliates.
        -:    3:
        -:    4:   This program is free software; you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License, version 2.0,
        -:    6:   as published by the Free Software Foundation.
        -:    7:
        -:    8:   This program is also distributed with certain software (including
        -:    9:   but not limited to OpenSSL) that is licensed under separate terms,
        -:   10:   as designated in a particular file or component or in included license
        -:   11:   documentation.  The authors of MySQL hereby grant you an additional
        -:   12:   permission to link the program and your derivative works with the
        -:   13:   separately licensed software that they have included with MySQL.
        -:   14:
        -:   15:   This program is distributed in the hope that it will be useful,
        -:   16:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   17:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   18:   GNU General Public License, version 2.0, for more details.
        -:   19:
        -:   20:   You should have received a copy of the GNU General Public License
        -:   21:   along with this program; if not, write to the Free Software
        -:   22:   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */
        -:   23:
        -:   24:#ifndef M_STRING_INCLUDED
        -:   25:#define M_STRING_INCLUDED
        -:   26:
        -:   27:/**
        -:   28:  @file include/m_string.h
        -:   29:*/
        -:   30:
        -:   31:#include <float.h>
        -:   32:#include <limits.h>
        -:   33:#include <stdbool.h>  // IWYU pragma: keep
        -:   34:#include <stdint.h>
        -:   35:#include <stdio.h>
        -:   36:#include <stdlib.h>
        -:   37:#include <string.h>
        -:   38:
        -:   39:#include <algorithm>
        -:   40:
        -:   41:#include "decimal.h"
        -:   42:#include "lex_string.h"
        -:   43:#include "my_config.h"
        -:   44:#include "my_inttypes.h"
        -:   45:#include "my_macros.h"
        -:   46:
        -:   47:/**
        -:   48:  Definition of the null string (a null pointer of type char *),
        -:   49:  used in some of our string handling code. New code should use
        -:   50:  nullptr instead.
        -:   51:*/
        -:   52:#define NullS (char *)0
        -:   53:
        -:   54:/*
        -:   55:  my_str_malloc(), my_str_realloc() and my_str_free() are assigned to
        -:   56:  implementations in strings/alloc.cc, but can be overridden in
        -:   57:  the calling program.
        -:   58: */
        -:   59:extern void *(*my_str_malloc)(size_t);
        -:   60:extern void *(*my_str_realloc)(void *, size_t);
        -:   61:extern void (*my_str_free)(void *);
        -:   62:
        -:   63:/* Declared in int2str.cc. */
        -:   64:extern const char _dig_vec_upper[];
        -:   65:extern const char _dig_vec_lower[];
        -:   66:
        -:   67:/* Prototypes for string functions */
        -:   68:
        -:   69:extern char *strmake(char *dst, const char *src, size_t length);
        -:   70:extern char *strcont(char *src, const char *set);
        -:   71:extern char *strxmov(char *dst, const char *src, ...);
        -:   72:extern char *strxnmov(char *dst, size_t len, const char *src, ...);
        -:   73:
        -:   74:/*
        -:   75:  bchange(dst, old_length, src, new_length, tot_length)
        -:   76:  replaces old_length characters at dst to new_length characters from
        -:   77:  src in a buffer with tot_length bytes.
        -:   78:*/
        -:   79:static inline void bchange(uchar *dst, size_t old_length, const uchar *src,
        -:   80:                           size_t new_length, size_t tot_length) {
        -:   81:  memmove(dst + new_length, dst + old_length, tot_length - old_length);
        -:   82:  memcpy(dst, src, new_length);
        -:   83:}
        -:   84:
        -:   85:/*
        -:   86:  strend(s) returns a character pointer to the NUL which ends s.  That
        -:   87:  is,  strend(s)-s  ==  strlen(s). This is useful for adding things at
        -:   88:  the end of strings.  It is redundant, because  strchr(s,'\0')  could
        -:   89:  be used instead, but this is clearer and faster.
        -:   90:*/
        -:   91:static inline const char *strend(const char *s) {
        -:   92:  while (*s++)
        -:   93:    ;
        -:   94:  return s - 1;
        -:   95:}
        -:   96:
        -:   97:static inline char *strend(char *s) {
        -:   98:  while (*s++)
        -:   99:    ;
        -:  100:  return s - 1;
        -:  101:}
        -:  102:
        -:  103:/*
        -:  104:  strcend(s, c) returns a pointer to the  first  place  in  s where  c
        -:  105:  occurs,  or a pointer to the end-null of s if c does not occur in s.
        -:  106:*/
        -:  107:static inline const char *strcend(const char *s, char c) {
        -:  108:  for (;;) {
        -:  109:    if (*s == c) return s;
        -:  110:    if (!*s++) return s - 1;
        -:  111:  }
        -:  112:}
        -:  113:
        -:  114:/*
        -:  115:  strfill(dest, len, fill) makes a string of fill-characters. The result
        -:  116:  string is of length == len. The des+len character is allways set to NULL.
        -:  117:  strfill() returns pointer to dest+len;
        -:  118:*/
        -:  119:static inline char *strfill(char *s, size_t len, char fill) {
        -:  120:  while (len--) *s++ = fill;
        -:  121:  *(s) = '\0';
        -:  122:  return (s);
        -:  123:}
        -:  124:
        -:  125:/*
        -:  126:  my_stpmov(dst, src) moves all the  characters  of  src  (including  the
        -:  127:  closing NUL) to dst, and returns a pointer to the new closing NUL in
        -:  128:  dst.	 The similar UNIX routine strcpy returns the old value of dst,
        -:  129:  which I have never found useful.  my_stpmov(my_stpmov(dst,a),b) moves a//b
        -:  130:  into dst, which seems useful.
        -:  131:*/
        -:  132:static inline char *my_stpmov(char *dst, const char *src) {
        -:  133:  while ((*dst++ = *src++))
        -:  134:    ;
        -:  135:  return dst - 1;
        -:  136:}
        -:  137:
        -:  138:/*
        -:  139:  my_stpnmov(dst,src,length) moves length characters, or until end, of src to
        -:  140:  dst and appends a closing NUL to dst if src is shorter than length.
        -:  141:  The result is a pointer to the first NUL in dst, or is dst+n if dst was
        -:  142:  truncated.
        -:  143:*/
        -:  144:static inline char *my_stpnmov(char *dst, const char *src, size_t n) {
        -:  145:  while (n-- != 0) {
        -:  146:    if (!(*dst++ = *src++)) return (char *)dst - 1;
        -:  147:  }
        -:  148:  return dst;
        -:  149:}
        -:  150:
        -:  151:/**
        -:  152:   Copy a string from src to dst until (and including) terminating null byte.
        -:  153:
        -:  154:   @param dst   Destination
        -:  155:   @param src   Source
        -:  156:
        -:  157:   @note src and dst cannot overlap.
        -:  158:         Use my_stpmov() if src and dst overlaps.
        -:  159:
        -:  160:   @note Unsafe, consider using my_stpnpy() instead.
        -:  161:
        -:  162:   @return pointer to terminating null byte.
        -:  163:*/
        -:  164:static inline char *my_stpcpy(char *dst, const char *src) {
        -:  165:#if defined(HAVE_BUILTIN_STPCPY)
        -:  166:  /*
        -:  167:    If __builtin_stpcpy() is available, use it instead of stpcpy(), since GCC in
        -:  168:    some situations is able to transform __builtin_stpcpy() into more efficient
        -:  169:    strcpy() or memcpy() calls. It does not perform these transformations for a
        -:  170:    plain call to stpcpy() when the compiler runs in strict mode. See GCC bug
        -:  171:    82429.
        -:  172:  */
        -:  173:  return __builtin_stpcpy(dst, src);
        -:  174:#elif defined(HAVE_STPCPY)
        -:  175:  return stpcpy(dst, src);
        -:  176:#else
        -:  177:  /* Fallback to implementation supporting overlap. */
        -:  178:  return my_stpmov(dst, src);
        -:  179:#endif
        -:  180:}
        -:  181:
        -:  182:/**
        -:  183:   Copy fixed-size string from src to dst.
        -:  184:
        -:  185:   @param dst   Destination
        -:  186:   @param src   Source
        -:  187:   @param n     Maximum number of characters to copy.
        -:  188:
        -:  189:   @note src and dst cannot overlap
        -:  190:         Use my_stpnmov() if src and dst overlaps.
        -:  191:
        -:  192:   @return pointer to terminating null byte.
        -:  193:*/
        -:  194:static inline char *my_stpncpy(char *dst, const char *src, size_t n) {
        -:  195:#if defined(HAVE_STPNCPY)
        -:  196:  return stpncpy(dst, src, n);
        -:  197:#else
        -:  198:  /* Fallback to implementation supporting overlap. */
        -:  199:  return my_stpnmov(dst, src, n);
        -:  200:#endif
        -:  201:}
        -:  202:
        -:  203:static inline longlong my_strtoll(const char *nptr, char **endptr, int base) {
        -:  204:#if defined _WIN32
        -:  205:  return _strtoi64(nptr, endptr, base);
        -:  206:#else
        -:  207:  return strtoll(nptr, endptr, base);
        -:  208:#endif
        -:  209:}
        -:  210:
        -:  211:static inline ulonglong my_strtoull(const char *nptr, char **endptr, int base) {
        -:  212:#if defined _WIN32
        -:  213:  return _strtoui64(nptr, endptr, base);
        -:  214:#else
        -:  215:  return strtoull(nptr, endptr, base);
        -:  216:#endif
        -:  217:}
        -:  218:
    #####:  219:static inline char *my_strtok_r(char *str, const char *delim, char **saveptr) {
        -:  220:#if defined _WIN32
        -:  221:  return strtok_s(str, delim, saveptr);
        -:  222:#else
    #####:  223:  return strtok_r(str, delim, saveptr);
        -:  224:#endif
        -:  225:}
        -:  226:
        -:  227:/* native_ rather than my_ since my_strcasecmp already exists */
        -:  228:static inline int native_strcasecmp(const char *s1, const char *s2) {
        -:  229:#if defined _WIN32
        -:  230:  return _stricmp(s1, s2);
        -:  231:#else
        -:  232:  return strcasecmp(s1, s2);
        -:  233:#endif
        -:  234:}
        -:  235:
        -:  236:/* native_ rather than my_ for consistency with native_strcasecmp */
        -:  237:static inline int native_strncasecmp(const char *s1, const char *s2, size_t n) {
        -:  238:#if defined _WIN32
        -:  239:  return _strnicmp(s1, s2, n);
        -:  240:#else
        -:  241:  return strncasecmp(s1, s2, n);
        -:  242:#endif
        -:  243:}
        -:  244:
        -:  245:/*
        -:  246:  is_prefix(s, t) returns 1 if s starts with t.
        -:  247:  A empty t is always a prefix.
        -:  248:*/
        -:  249:static inline int is_prefix(const char *s, const char *t) {
        -:  250:  while (*t)
        -:  251:    if (*s++ != *t++) return 0;
        -:  252:  return 1; /* WRONG */
        -:  253:}
        -:  254:
        -:  255:/*
        -:  256:   Replace the deprecated character set name "utf8" with "utf8mb3".
        -:  257: */
        -:  258:static inline const char *replace_utf8_utf8mb3(const char *csname) {
        -:  259:  return (native_strcasecmp(csname, "utf8") != 0) ? csname : "utf8mb3";
        -:  260:}
        -:  261:
        -:  262:/* Conversion routines */
        -:  263:typedef enum { MY_GCVT_ARG_FLOAT, MY_GCVT_ARG_DOUBLE } my_gcvt_arg_type;
        -:  264:
        -:  265:double my_strtod(const char *str, const char **end, int *error);
        -:  266:size_t my_fcvt(double x, int precision, char *to, bool *error);
        -:  267:size_t my_fcvt_compact(double x, char *to, bool *error);
        -:  268:size_t my_gcvt(double x, my_gcvt_arg_type type, int width, char *to,
        -:  269:               bool *error);
        -:  270:
        -:  271:/*
        -:  272:  The longest string my_fcvt can return is 311 + "precision" bytes.
        -:  273:  Here we assume that we never call my_fcvt() with precision >=
        -:  274:  DECIMAL_NOT_SPECIFIED
        -:  275:  (+ 1 byte for the terminating '\0').
        -:  276:*/
        -:  277:static constexpr int FLOATING_POINT_BUFFER{311 + DECIMAL_NOT_SPECIFIED};
        -:  278:
        -:  279:/*
        -:  280:  We want to use the 'e' format in some cases even if we have enough space
        -:  281:  for the 'f' one just to mimic sprintf("%.15g") behavior for large integers,
        -:  282:  and to improve it for numbers < 10^(-4).
        -:  283:  That is, for |x| < 1 we require |x| >= 10^(-15), and for |x| > 1 we require
        -:  284:  it to be integer and be <= 10^DBL_DIG for the 'f' format to be used.
        -:  285:  We don't lose precision, but make cases like "1e200" or "0.00001" look nicer.
        -:  286:*/
        -:  287:#define MAX_DECPT_FOR_F_FORMAT DBL_DIG
        -:  288:
        -:  289:/*
        -:  290:  The maximum possible field width for my_gcvt() conversion.
        -:  291:  (DBL_DIG + 2) significant digits + sign + "." + ("e-NNN" or
        -:  292:  MAX_DECPT_FOR_F_FORMAT zeros for cases when |x|<1 and the 'f' format is used).
        -:  293:*/
        -:  294:#define MY_GCVT_MAX_FIELD_WIDTH \
        -:  295:  (DBL_DIG + 4 + std::max(5, MAX_DECPT_FOR_F_FORMAT))
        -:  296:
        -:  297:const char *str2int(const char *src, int radix, long lower, long upper,
        -:  298:                    long *val);
        -:  299:longlong my_strtoll10(const char *nptr, const char **endptr, int *error);
        -:  300:char *ll2str(int64_t val, char *dst, int radix, bool upcase);
        -:  301:char *longlong10_to_str(int64_t val, char *dst, int radix);
        -:  302:
        -:  303:inline char *longlong2str(int64_t val, char *dst, int radix) {
        -:  304:  return ll2str(val, dst, radix, true);
        -:  305:}
        -:  306:
        -:  307:/*
        -:  308:  This function saves a longlong value in a buffer and returns the pointer to
        -:  309:  the buffer.
        -:  310:*/
        -:  311:static inline char *llstr(longlong value, char *buff) {
        -:  312:  longlong10_to_str(value, buff, -10);
        -:  313:  return buff;
        -:  314:}
        -:  315:
        -:  316:static inline char *ullstr(longlong value, char *buff) {
        -:  317:  longlong10_to_str(value, buff, 10);
        -:  318:  return buff;
        -:  319:}
        -:  320:
        -:  321:#define STRING_WITH_LEN(X) (X), ((sizeof(X) - 1))
        -:  322:
        -:  323:/**
        -:  324:  Skip trailing space (ASCII spaces only).
        -:  325:
        -:  326:  @return New end of the string.
        -:  327:*/
        -:  328:static inline const uchar *skip_trailing_space(const uchar *ptr, size_t len) {
        -:  329:  const uchar *end = ptr + len;
        -:  330:  while (end - ptr >= 8) {
        -:  331:    uint64_t chunk;
        -:  332:    memcpy(&chunk, end - 8, sizeof(chunk));
        -:  333:    if (chunk != 0x2020202020202020ULL) break;
        -:  334:    end -= 8;
        -:  335:  }
        -:  336:  while (end > ptr && end[-1] == 0x20) end--;
        -:  337:  return (end);
        -:  338:}
        -:  339:
        -:  340:/*
        -:  341:  Format a double (representing number of bytes) into a human-readable string.
        -:  342:
        -:  343:  @param buf     Buffer used for printing
        -:  344:  @param buf_len Length of buffer
        -:  345:  @param dbl_val Value to be formatted
        -:  346:
        -:  347:  @note
        -:  348:    Sample output format: 42 1K 234M 2G
        -:  349:    If we exceed ULLONG_MAX YiB we give up, and convert to "+INF".
        -:  350:
        -:  351:  @todo Consider writing KiB GiB etc, since we use 1024 rather than 1000
        -:  352: */
        -:  353:static inline void human_readable_num_bytes(char *buf, int buf_len,
        -:  354:                                            double dbl_val) {
        -:  355:  const char size[] = {'\0', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'};
        -:  356:  unsigned int i;
        -:  357:  for (i = 0; dbl_val > 1024 && i < sizeof(size) - 1; i++) dbl_val /= 1024;
        -:  358:  const char mult = size[i];
        -:  359:  // 18446744073709551615 Yottabytes should be enough for most ...
        -:  360:  // ULLONG_MAX is not exactly representable as a double. This is the largest
        -:  361:  // double that is still below ULLONG_MAX.
        -:  362:  if (dbl_val > 18446744073709549568.0)
        -:  363:    snprintf(buf, buf_len, "+INF");
        -:  364:  else
        -:  365:    snprintf(buf, buf_len, "%llu%c", (unsigned long long)dbl_val, mult);
        -:  366:}
        -:  367:
        -:  368:static inline void lex_string_set(LEX_STRING *lex_str, char *c_str) {
        -:  369:  lex_str->str = c_str;
        -:  370:  lex_str->length = strlen(c_str);
        -:  371:}
        -:  372:
        -:  373:static inline void lex_cstring_set(LEX_CSTRING *lex_str, const char *c_str) {
        -:  374:  lex_str->str = c_str;
        -:  375:  lex_str->length = strlen(c_str);
        -:  376:}
        -:  377:
        -:  378:#endif  // M_STRING_INCLUDED
