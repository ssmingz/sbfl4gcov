        -:    0:Source:/mnt/hwshare/gcov_mysql/mysql_9_dfb4f427442f5fc4112a4847c09e1c51e420077c_pre/vio/viosslfactories.cc
        -:    0:Graph:viosslfactories.cc.gcno
        -:    0:Data:viosslfactories.cc.gcda
        -:    0:Runs:4
        -:    0:Programs:2
        -:    1:/* Copyright (c) 2000, 2021, Oracle and/or its affiliates.
        -:    2:
        -:    3:   This program is free software; you can redistribute it and/or modify
        -:    4:   it under the terms of the GNU General Public License, version 2.0,
        -:    5:   as published by the Free Software Foundation.
        -:    6:
        -:    7:   This program is also distributed with certain software (including
        -:    8:   but not limited to OpenSSL) that is licensed under separate terms,
        -:    9:   as designated in a particular file or component or in included license
        -:   10:   documentation.  The authors of MySQL hereby grant you an additional
        -:   11:   permission to link the program and your derivative works with the
        -:   12:   separately licensed software that they have included with MySQL.
        -:   13:
        -:   14:   Without limiting anything contained in the foregoing, this file,
        -:   15:   which is part of C Driver for MySQL (Connector/C), is also subject to the
        -:   16:   Universal FOSS Exception, version 1.0, a copy of which can be found at
        -:   17:   http://oss.oracle.com/licenses/universal-foss-exception.
        -:   18:
        -:   19:   This program is distributed in the hope that it will be useful,
        -:   20:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   21:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   22:   GNU General Public License, version 2.0, for more details.
        -:   23:
        -:   24:   You should have received a copy of the GNU General Public License
        -:   25:   along with this program; if not, write to the Free Software
        -:   26:   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */
        -:   27:
        -:   28:#include <sstream>
        -:   29:#include <string>
        -:   30:
        -:   31:#include "m_ctype.h"
        -:   32:#include "my_dbug.h"
        -:   33:#include "my_inttypes.h"
        -:   34:#include "my_loglevel.h"
        -:   35:#if !defined(HAVE_PSI_INTERFACE)
        -:   36:#include "mysql/psi/mysql_rwlock.h"
        -:   37:#endif
        -:   38:#include "mysql/service_mysql_alloc.h"
        -:   39:#include "mysys_err.h"
        -:   40:#include "vio/vio_priv.h"
        -:   41:
        -:   42:#include <openssl/dh.h>
        -:   43:
        -:   44:#if OPENSSL_VERSION_NUMBER < 0x10002000L
        -:   45:#include <openssl/ec.h>
        -:   46:#endif /* OPENSSL_VERSION_NUMBER < 0x10002000L */
        -:   47:
        -:   48:#define TLS_VERSION_OPTION_SIZE 256
        -:   49:
        -:   50:/*
        -:   51:  1. Cipher preference order: P1 > A1 > A2 > D1
        -:   52:  2. Blocked ciphers are not allowed
        -:   53:*/
        -:   54:
        -:   55:static const char mandatory_p1[] = {
        -:   56:    "ECDHE-ECDSA-AES128-GCM-SHA256:"
        -:   57:    "ECDHE-ECDSA-AES256-GCM-SHA384:"
        -:   58:    "ECDHE-RSA-AES128-GCM-SHA256:"
        -:   59:    "ECDHE-ECDSA-AES128-SHA256:"
        -:   60:    "ECDHE-RSA-AES128-SHA256"};
        -:   61:
        -:   62:static const char optional_a1[] = {
        -:   63:    "ECDHE-RSA-AES256-GCM-SHA384:"
        -:   64:    "ECDHE-ECDSA-AES256-SHA384:"
        -:   65:    "ECDHE-RSA-AES256-SHA384:"
        -:   66:    "DHE-RSA-AES128-GCM-SHA256:"
        -:   67:    "DHE-DSS-AES128-GCM-SHA256:"
        -:   68:    "DHE-RSA-AES128-SHA256:"
        -:   69:    "DHE-DSS-AES128-SHA256:"
        -:   70:    "DHE-DSS-AES256-GCM-SHA384:"
        -:   71:    "DHE-RSA-AES256-SHA256:"
        -:   72:    "DHE-DSS-AES256-SHA256:"
        -:   73:    "DHE-RSA-AES256-GCM-SHA384"};
        -:   74:
        -:   75:static const char optional_a2[] = {
        -:   76:    "DH-DSS-AES128-GCM-SHA256:"
        -:   77:    "ECDH-ECDSA-AES128-GCM-SHA256:"
        -:   78:    "DH-DSS-AES256-GCM-SHA384:"
        -:   79:    "ECDH-ECDSA-AES256-GCM-SHA384:"
        -:   80:    "DH-DSS-AES128-SHA256:"
        -:   81:    "ECDH-ECDSA-AES128-SHA256:"
        -:   82:    "DH-DSS-AES256-SHA256:"
        -:   83:    "ECDH-ECDSA-AES256-SHA384:"
        -:   84:    "DH-RSA-AES128-GCM-SHA256:"
        -:   85:    "ECDH-RSA-AES128-GCM-SHA256:"
        -:   86:    "DH-RSA-AES256-GCM-SHA384:"
        -:   87:    "ECDH-RSA-AES256-GCM-SHA384:"
        -:   88:    "DH-RSA-AES128-SHA256:"
        -:   89:    "ECDH-RSA-AES128-SHA256:"
        -:   90:    "DH-RSA-AES256-SHA256:"
        -:   91:    "ECDH-RSA-AES256-SHA384"};
        -:   92:
        -:   93:static const char optional_d1[] = {
        -:   94:    "ECDHE-RSA-AES128-SHA:"
        -:   95:    "ECDHE-ECDSA-AES128-SHA:"
        -:   96:    "ECDHE-RSA-AES256-SHA:"
        -:   97:    "ECDHE-ECDSA-AES256-SHA:"
        -:   98:    "DHE-DSS-AES128-SHA:"
        -:   99:    "DHE-RSA-AES128-SHA:"
        -:  100:    "DHE-DSS-AES256-SHA:"
        -:  101:    "DHE-RSA-AES256-SHA:"
        -:  102:    "DH-DSS-AES128-SHA:"
        -:  103:    "ECDH-ECDSA-AES128-SHA:"
        -:  104:    "AES256-SHA:"
        -:  105:    "DH-DSS-AES256-SHA:"
        -:  106:    "ECDH-ECDSA-AES256-SHA:"
        -:  107:    "DH-RSA-AES128-SHA:"
        -:  108:    "ECDH-RSA-AES128-SHA:"
        -:  109:    "DH-RSA-AES256-SHA:"
        -:  110:    "ECDH-RSA-AES256-SHA:"
        -:  111:    "CAMELLIA256-SHA:"
        -:  112:    "CAMELLIA128-SHA:"
        -:  113:    "AES128-GCM-SHA256:"
        -:  114:    "AES256-GCM-SHA384:"
        -:  115:    "AES128-SHA256:"
        -:  116:    "AES256-SHA256:"
        -:  117:    "AES128-SHA"};
        -:  118:
        -:  119:static const char tls_cipher_blocked[] = {
        -:  120:    "!aNULL:"
        -:  121:    "!eNULL:"
        -:  122:    "!EXPORT:"
        -:  123:    "!LOW:"
        -:  124:    "!MD5:"
        -:  125:    "!DES:"
        -:  126:    "!RC2:"
        -:  127:    "!RC4:"
        -:  128:    "!PSK:"
        -:  129:    "!DES-CBC3-SHA:"
        -:  130:    "!DHE-DSS-DES-CBC3-SHA:"
        -:  131:    "!DHE-RSA-DES-CBC3-SHA:"
        -:  132:    "!ECDH-RSA-DES-CBC3-SHA:"
        -:  133:    "!ECDH-ECDSA-DES-CBC3-SHA:"
        -:  134:    "!ECDHE-RSA-DES-CBC3-SHA:"
        -:  135:    "!ECDHE-ECDSA-DES-CBC3-SHA:"
        -:  136:    "!DH-RSA-DES-CBC3-SHA:"
        -:  137:    "!DH-DSS-DES-CBC3-SHA"};
        -:  138:
        -:  139:static bool ssl_initialized = false;
        -:  140:
        -:  141:/*
        -:  142:  Diffie-Hellman key.
        -:  143:  Generated using: >openssl dhparam -5 -C 2048
        -:  144:
        -:  145:  -----BEGIN DH PARAMETERS-----
        -:  146:  MIIBCAKCAQEAil36wGZ2TmH6ysA3V1xtP4MKofXx5n88xq/aiybmGnReZMviCPEJ
        -:  147:  46+7VCktl/RZ5iaDH1XNG1dVQmznt9pu2G3usU+k1/VB4bQL4ZgW4u0Wzxh9PyXD
        -:  148:  glm99I9Xyj4Z5PVE4MyAsxCRGA1kWQpD9/zKAegUBPLNqSo886Uqg9hmn8ksyU9E
        -:  149:  BV5eAEciCuawh6V0O+Sj/C3cSfLhgA0GcXp3OqlmcDu6jS5gWjn3LdP1U0duVxMB
        -:  150:  h/neTSCSvtce4CAMYMjKNVh9P1nu+2d9ZH2Od2xhRIqMTfAS1KTqF3VmSWzPFCjG
        -:  151:  mjxx/bg6bOOjpgZapvB6ABWlWmRmAAWFtwIBBQ==
        -:  152:  -----END DH PARAMETERS-----
        -:  153: */
        -:  154:static unsigned char dh2048_p[] = {
        -:  155:    0x8A, 0x5D, 0xFA, 0xC0, 0x66, 0x76, 0x4E, 0x61, 0xFA, 0xCA, 0xC0, 0x37,
        -:  156:    0x57, 0x5C, 0x6D, 0x3F, 0x83, 0x0A, 0xA1, 0xF5, 0xF1, 0xE6, 0x7F, 0x3C,
        -:  157:    0xC6, 0xAF, 0xDA, 0x8B, 0x26, 0xE6, 0x1A, 0x74, 0x5E, 0x64, 0xCB, 0xE2,
        -:  158:    0x08, 0xF1, 0x09, 0xE3, 0xAF, 0xBB, 0x54, 0x29, 0x2D, 0x97, 0xF4, 0x59,
        -:  159:    0xE6, 0x26, 0x83, 0x1F, 0x55, 0xCD, 0x1B, 0x57, 0x55, 0x42, 0x6C, 0xE7,
        -:  160:    0xB7, 0xDA, 0x6E, 0xD8, 0x6D, 0xEE, 0xB1, 0x4F, 0xA4, 0xD7, 0xF5, 0x41,
        -:  161:    0xE1, 0xB4, 0x0B, 0xE1, 0x98, 0x16, 0xE2, 0xED, 0x16, 0xCF, 0x18, 0x7D,
        -:  162:    0x3F, 0x25, 0xC3, 0x82, 0x59, 0xBD, 0xF4, 0x8F, 0x57, 0xCA, 0x3E, 0x19,
        -:  163:    0xE4, 0xF5, 0x44, 0xE0, 0xCC, 0x80, 0xB3, 0x10, 0x91, 0x18, 0x0D, 0x64,
        -:  164:    0x59, 0x0A, 0x43, 0xF7, 0xFC, 0xCA, 0x01, 0xE8, 0x14, 0x04, 0xF2, 0xCD,
        -:  165:    0xA9, 0x2A, 0x3C, 0xF3, 0xA5, 0x2A, 0x83, 0xD8, 0x66, 0x9F, 0xC9, 0x2C,
        -:  166:    0xC9, 0x4F, 0x44, 0x05, 0x5E, 0x5E, 0x00, 0x47, 0x22, 0x0A, 0xE6, 0xB0,
        -:  167:    0x87, 0xA5, 0x74, 0x3B, 0xE4, 0xA3, 0xFC, 0x2D, 0xDC, 0x49, 0xF2, 0xE1,
        -:  168:    0x80, 0x0D, 0x06, 0x71, 0x7A, 0x77, 0x3A, 0xA9, 0x66, 0x70, 0x3B, 0xBA,
        -:  169:    0x8D, 0x2E, 0x60, 0x5A, 0x39, 0xF7, 0x2D, 0xD3, 0xF5, 0x53, 0x47, 0x6E,
        -:  170:    0x57, 0x13, 0x01, 0x87, 0xF9, 0xDE, 0x4D, 0x20, 0x92, 0xBE, 0xD7, 0x1E,
        -:  171:    0xE0, 0x20, 0x0C, 0x60, 0xC8, 0xCA, 0x35, 0x58, 0x7D, 0x3F, 0x59, 0xEE,
        -:  172:    0xFB, 0x67, 0x7D, 0x64, 0x7D, 0x8E, 0x77, 0x6C, 0x61, 0x44, 0x8A, 0x8C,
        -:  173:    0x4D, 0xF0, 0x12, 0xD4, 0xA4, 0xEA, 0x17, 0x75, 0x66, 0x49, 0x6C, 0xCF,
        -:  174:    0x14, 0x28, 0xC6, 0x9A, 0x3C, 0x71, 0xFD, 0xB8, 0x3A, 0x6C, 0xE3, 0xA3,
        -:  175:    0xA6, 0x06, 0x5A, 0xA6, 0xF0, 0x7A, 0x00, 0x15, 0xA5, 0x5A, 0x64, 0x66,
        -:  176:    0x00, 0x05, 0x85, 0xB7,
        -:  177:};
        -:  178:
        -:  179:static unsigned char dh2048_g[] = {
        -:  180:    0x05,
        -:  181:};
        -:  182:
    #####:  183:static DH *get_dh2048(void) {
        -:  184:  DH *dh;
    #####:  185:  if ((dh = DH_new())) {
    #####:  186:    BIGNUM *p = BN_bin2bn(dh2048_p, sizeof(dh2048_p), nullptr);
    #####:  187:    BIGNUM *g = BN_bin2bn(dh2048_g, sizeof(dh2048_g), nullptr);
    #####:  188:    if (!p || !g
        -:  189:#if OPENSSL_VERSION_NUMBER >= 0x10100000L
    #####:  190:        || !DH_set0_pqg(dh, p, nullptr, g)
        -:  191:#endif /* OPENSSL_VERSION_NUMBER >= 0x10100000L */
        -:  192:    ) {
        -:  193:      /* DH_free() will free 'p' and 'g' at once. */
    #####:  194:      DH_free(dh);
    #####:  195:      return nullptr;
        -:  196:    }
        -:  197:#if OPENSSL_VERSION_NUMBER < 0x10100000L
        -:  198:    dh->p = p;
        -:  199:    dh->g = g;
        -:  200:#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */
        -:  201:  }
    #####:  202:  return (dh);
        -:  203:}
        -:  204:
        1:  205:static void report_errors() {
        -:  206:  unsigned long l;
        -:  207:  const char *file;
        -:  208:  const char *data;
        -:  209:  int line, flags;
        -:  210:
        2:  211:  DBUG_TRACE;
        -:  212:
       1*:  213:  while ((l = ERR_get_error_line_data(&file, &line, &data, &flags)) > 0) {
        -:  214:#ifndef NDEBUG /* Avoid warning */
        -:  215:    char buf[200];
    #####:  216:    DBUG_PRINT("error", ("OpenSSL: %s:%s:%d:%s\n", ERR_error_string(l, buf),
        -:  217:                         file, line, (flags & ERR_TXT_STRING) ? data : ""));
        -:  218:#endif
        -:  219:  }
        1:  220:}
        -:  221:
        -:  222:static const char *ssl_error_string[] = {
        -:  223:    "No error",
        -:  224:    "Unable to get certificate",
        -:  225:    "Unable to get private key",
        -:  226:    "Private key does not match the certificate public key",
        -:  227:    "SSL_CTX_set_default_verify_paths failed",
        -:  228:    "Failed to set ciphers to use",
        -:  229:    "SSL_CTX_new failed",
        -:  230:    "SSL context is not usable without certificate and private key",
        -:  231:    "SSL_CTX_set_tmp_dh failed",
        -:  232:    "TLS version is invalid",
        -:  233:    "Failed to set ecdh information",
        -:  234:    "Failed to set X509 verification parameter"};
        -:  235:
        1:  236:const char *sslGetErrString(enum enum_ssl_init_error e) {
       1*:  237:  assert(SSL_INITERR_NOERROR < e && e < SSL_INITERR_LASTERR);
        1:  238:  return ssl_error_string[e];
        -:  239:}
        -:  240:
        1:  241:static int vio_set_cert_stuff(SSL_CTX *ctx, const char *cert_file,
        -:  242:                              const char *key_file,
        -:  243:                              enum enum_ssl_init_error *error) {
        2:  244:  DBUG_TRACE;
       1*:  245:  DBUG_PRINT("enter", ("ctx: %p  cert_file: %s  key_file: %s", ctx, cert_file,
        -:  246:                       key_file));
        -:  247:
       1*:  248:  if (!cert_file && key_file) cert_file = key_file;
        -:  249:
       1*:  250:  if (!key_file && cert_file) key_file = cert_file;
        -:  251:
       1*:  252:  if (cert_file &&
    #####:  253:      SSL_CTX_use_certificate_file(ctx, cert_file, SSL_FILETYPE_PEM) <= 0) {
    #####:  254:    *error = SSL_INITERR_CERT;
    #####:  255:    DBUG_PRINT("error",
        -:  256:               ("%s from file '%s'", sslGetErrString(*error), cert_file));
    #####:  257:    DBUG_EXECUTE("error", ERR_print_errors_fp(DBUG_FILE););
    #####:  258:    my_message_local(ERROR_LEVEL, EE_SSL_ERROR_FROM_FILE,
        -:  259:                     sslGetErrString(*error), cert_file);
    #####:  260:    return 1;
        -:  261:  }
        -:  262:
       1*:  263:  if (key_file &&
    #####:  264:      SSL_CTX_use_PrivateKey_file(ctx, key_file, SSL_FILETYPE_PEM) <= 0) {
    #####:  265:    *error = SSL_INITERR_KEY;
    #####:  266:    DBUG_PRINT("error",
        -:  267:               ("%s from file '%s'", sslGetErrString(*error), key_file));
    #####:  268:    DBUG_EXECUTE("error", ERR_print_errors_fp(DBUG_FILE););
    #####:  269:    my_message_local(ERROR_LEVEL, EE_SSL_ERROR_FROM_FILE,
        -:  270:                     sslGetErrString(*error), key_file);
    #####:  271:    return 1;
        -:  272:  }
        -:  273:
        -:  274:  /*
        -:  275:    If we are using DSA, we can copy the parameters from the private key
        -:  276:    Now we know that a key and cert have been set against the SSL context
        -:  277:  */
       1*:  278:  if (cert_file && !SSL_CTX_check_private_key(ctx)) {
    #####:  279:    *error = SSL_INITERR_NOMATCH;
    #####:  280:    DBUG_PRINT("error", ("%s", sslGetErrString(*error)));
    #####:  281:    DBUG_EXECUTE("error", ERR_print_errors_fp(DBUG_FILE););
    #####:  282:    my_message_local(ERROR_LEVEL, EE_SSL_ERROR, sslGetErrString(*error));
    #####:  283:    return 1;
        -:  284:  }
        -:  285:
        1:  286:  return 0;
        -:  287:}
        -:  288:
        -:  289:/*
        -:  290:  OpenSSL 1.1 supports native platform threads,
        -:  291:  so we don't need the following callback functions.
        -:  292:*/
        -:  293:#if OPENSSL_VERSION_NUMBER < 0x10100000L
        -:  294:/* OpenSSL specific */
        -:  295:
        -:  296:#ifdef HAVE_PSI_INTERFACE
        -:  297:static PSI_rwlock_key key_rwlock_openssl;
        -:  298:
        -:  299:static PSI_rwlock_info openssl_rwlocks[] = {
        -:  300:    {&key_rwlock_openssl, "CRYPTO_dynlock_value::lock", 0, 0, nullptr}};
        -:  301:#endif
        -:  302:
        -:  303:typedef struct CRYPTO_dynlock_value {
        -:  304:  mysql_rwlock_t lock;
        -:  305:} openssl_lock_t;
        -:  306:
        -:  307:/* Array of locks used by openssl internally for thread synchronization.
        -:  308:   The number of locks is equal to CRYPTO_num_locks.
        -:  309:*/
        -:  310:static openssl_lock_t *openssl_stdlocks;
        -:  311:
        -:  312:/*OpenSSL callback functions for multithreading. We implement all the functions
        -:  313:  as we are using our own locking mechanism.
        -:  314:*/
        -:  315:static void openssl_lock(int mode, openssl_lock_t *lock,
        -:  316:                         const char *file [[maybe_unused]],
        -:  317:                         int line [[maybe_unused]]) {
        -:  318:  int err;
        -:  319:  char const *what;
        -:  320:
        -:  321:  switch (mode) {
        -:  322:    case CRYPTO_LOCK | CRYPTO_READ:
        -:  323:      what = "read lock";
        -:  324:      err = mysql_rwlock_rdlock(&lock->lock);
        -:  325:      break;
        -:  326:    case CRYPTO_LOCK | CRYPTO_WRITE:
        -:  327:      what = "write lock";
        -:  328:      err = mysql_rwlock_wrlock(&lock->lock);
        -:  329:      break;
        -:  330:    case CRYPTO_UNLOCK | CRYPTO_READ:
        -:  331:    case CRYPTO_UNLOCK | CRYPTO_WRITE:
        -:  332:      what = "unlock";
        -:  333:      err = mysql_rwlock_unlock(&lock->lock);
        -:  334:      break;
        -:  335:    default:
        -:  336:      /* Unknown locking mode. */
        -:  337:      DBUG_PRINT("error",
        -:  338:                 ("Fatal OpenSSL: %s:%d: interface problem (mode=0x%x)\n", file,
        -:  339:                  line, mode));
        -:  340:
        -:  341:      fprintf(stderr, "Fatal: OpenSSL interface problem (mode=0x%x)", mode);
        -:  342:      fflush(stderr);
        -:  343:      abort();
        -:  344:  }
        -:  345:  if (err) {
        -:  346:    DBUG_PRINT("error", ("Fatal OpenSSL: %s:%d: can't %s OpenSSL lock\n", file,
        -:  347:                         line, what));
        -:  348:
        -:  349:    fprintf(stderr, "Fatal: can't %s OpenSSL lock", what);
        -:  350:    fflush(stderr);
        -:  351:    abort();
        -:  352:  }
        -:  353:}
        -:  354:
        -:  355:static void openssl_lock_function(int mode, int n,
        -:  356:                                  const char *file [[maybe_unused]],
        -:  357:                                  int line [[maybe_unused]]) {
        -:  358:  if (n < 0 || n > CRYPTO_num_locks()) {
        -:  359:    /* Lock number out of bounds. */
        -:  360:    DBUG_PRINT("error", ("Fatal OpenSSL: %s:%d: interface problem (n = %d)",
        -:  361:                         file, line, n));
        -:  362:
        -:  363:    fprintf(stderr, "Fatal: OpenSSL interface problem (n = %d)", n);
        -:  364:    fflush(stderr);
        -:  365:    abort();
        -:  366:  }
        -:  367:  openssl_lock(mode, &openssl_stdlocks[n], file, line);
        -:  368:}
        -:  369:
        -:  370:static openssl_lock_t *openssl_dynlock_create(const char *file [[maybe_unused]],
        -:  371:                                              int line [[maybe_unused]]) {
        -:  372:  openssl_lock_t *lock;
        -:  373:
        -:  374:  DBUG_PRINT("info", ("openssl_dynlock_create: %s:%d", file, line));
        -:  375:
        -:  376:  lock = (openssl_lock_t *)my_malloc(PSI_NOT_INSTRUMENTED,
        -:  377:                                     sizeof(openssl_lock_t), MYF(0));
        -:  378:
        -:  379:#ifdef HAVE_PSI_INTERFACE
        -:  380:  mysql_rwlock_init(key_rwlock_openssl, &lock->lock);
        -:  381:#else
        -:  382:  mysql_rwlock_init(0, &lock->lock);
        -:  383:#endif
        -:  384:  return lock;
        -:  385:}
        -:  386:
        -:  387:static void openssl_dynlock_destroy(openssl_lock_t *lock,
        -:  388:                                    const char *file [[maybe_unused]],
        -:  389:                                    int line [[maybe_unused]]) {
        -:  390:  DBUG_PRINT("info", ("openssl_dynlock_destroy: %s:%d", file, line));
        -:  391:
        -:  392:  mysql_rwlock_destroy(&lock->lock);
        -:  393:  my_free(lock);
        -:  394:}
        -:  395:
        -:  396:static unsigned long openssl_id_function() {
        -:  397:  return (unsigned long)my_thread_self();
        -:  398:}
        -:  399:
        -:  400:// End of mutlithreading callback functions
        -:  401:
        -:  402:static void init_ssl_locks() {
        -:  403:  int i = 0;
        -:  404:#ifdef HAVE_PSI_INTERFACE
        -:  405:  const char *category = "sql";
        -:  406:  int count = static_cast<int>(array_elements(openssl_rwlocks));
        -:  407:  mysql_rwlock_register(category, openssl_rwlocks, count);
        -:  408:#endif
        -:  409:
        -:  410:  openssl_stdlocks = (openssl_lock_t *)OPENSSL_malloc(CRYPTO_num_locks() *
        -:  411:                                                      sizeof(openssl_lock_t));
        -:  412:  for (i = 0; i < CRYPTO_num_locks(); ++i)
        -:  413:#ifdef HAVE_PSI_INTERFACE
        -:  414:    mysql_rwlock_init(key_rwlock_openssl, &openssl_stdlocks[i].lock);
        -:  415:#else
        -:  416:    mysql_rwlock_init(0, &openssl_stdlocks[i].lock);
        -:  417:#endif
        -:  418:}
        -:  419:
        -:  420:static void set_lock_callback_functions(bool init) {
        -:  421:  CRYPTO_set_locking_callback(init ? openssl_lock_function : NULL);
        -:  422:  CRYPTO_set_id_callback(init ? openssl_id_function : NULL);
        -:  423:  CRYPTO_set_dynlock_create_callback(init ? openssl_dynlock_create : NULL);
        -:  424:  CRYPTO_set_dynlock_destroy_callback(init ? openssl_dynlock_destroy : NULL);
        -:  425:  CRYPTO_set_dynlock_lock_callback(init ? openssl_lock : NULL);
        -:  426:}
        -:  427:
        -:  428:static void init_lock_callback_functions() {
        -:  429:  set_lock_callback_functions(true);
        -:  430:}
        -:  431:
        -:  432:static void deinit_lock_callback_functions() {
        -:  433:  set_lock_callback_functions(false);
        -:  434:}
        -:  435:
        -:  436:#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */
        -:  437:
        4:  438:void vio_ssl_end() {
        4:  439:  if (ssl_initialized) {
        -:  440:#if OPENSSL_VERSION_NUMBER < 0x10100000L
        -:  441:    ERR_remove_thread_state(0);
        -:  442:#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */
        -:  443:    ERR_free_strings();
        -:  444:    EVP_cleanup();
        -:  445:
        -:  446:    CRYPTO_cleanup_all_ex_data();
        -:  447:
        -:  448:#if OPENSSL_VERSION_NUMBER < 0x10100000L
        -:  449:    deinit_lock_callback_functions();
        -:  450:
        -:  451:    for (int i = 0; i < CRYPTO_num_locks(); ++i)
        -:  452:      mysql_rwlock_destroy(&openssl_stdlocks[i].lock);
        -:  453:    OPENSSL_free(openssl_stdlocks);
        -:  454:
        -:  455:#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */
        4:  456:    ssl_initialized = false;
        -:  457:  }
        4:  458:}
        -:  459:
        4:  460:void ssl_start() {
        4:  461:  if (!ssl_initialized) {
        4:  462:    ssl_initialized = true;
        -:  463:
        4:  464:    SSL_library_init();
        4:  465:    OpenSSL_add_all_algorithms();
        4:  466:    SSL_load_error_strings();
        -:  467:
        -:  468:#if OPENSSL_VERSION_NUMBER < 0x10100000L
        -:  469:    init_ssl_locks();
        -:  470:    init_lock_callback_functions();
        -:  471:#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */
        -:  472:  }
        4:  473:}
        -:  474:
        -:  475:/**
        -:  476:  Set fips mode in openssl library,
        -:  477:  When we set fips mode ON/STRICT, it will perform following operations:
        -:  478:  1. Check integrity of openssl library
        -:  479:  2. Run fips related tests.
        -:  480:  3. Disable non fips complaint algorithms
        -:  481:  4. Should be set par process before openssl library initialization
        -:  482:  5. When FIPs mode ON(1/2), calling weak algorithms  may results into process
        -:  483:  abort.
        -:  484:
        -:  485:  @param [in]  fips_mode     0 for fips mode off, 1/2 for fips mode ON
        -:  486:  @param [out] err_string    If fips mode set fails, err_string will have detail
        -:  487:  failure reason.
        -:  488:
        -:  489:  @returns openssl set fips mode errors
        -:  490:    @retval non 1 for Error
        -:  491:    @retval 1 Success
        -:  492:*/
       18:  493:int set_fips_mode(const uint fips_mode, char err_string[OPENSSL_ERROR_LENGTH]) {
       18:  494:  int rc = -1;
       18:  495:  unsigned int fips_mode_old = -1;
       18:  496:  unsigned long err_library = 0;
       18:  497:  if (fips_mode > 2) {
    #####:  498:    goto EXIT;
        -:  499:  }
       18:  500:  fips_mode_old = FIPS_mode();
       18:  501:  if (fips_mode_old == fips_mode) {
       18:  502:    rc = 1;
       18:  503:    goto EXIT;
        -:  504:  }
    #####:  505:  if (!(rc = FIPS_mode_set(fips_mode))) {
        -:  506:    /*
        -:  507:      If OS doesn't have FIPS enabled openssl library and user sets FIPS mode
        -:  508:      ON, It fails with proper error. But in the same time it doesn't allow to
        -:  509:      perform any cryptographic operation. Now if FIPS mode set fails with
        -:  510:      error, setting old working FIPS mode value in the OpenSSL library. It will
        -:  511:      allow successful cryptographic operation and will not abort the server.
        -:  512:    */
    #####:  513:    FIPS_mode_set(fips_mode_old);
    #####:  514:    err_library = ERR_get_error();
    #####:  515:    ERR_error_string_n(err_library, err_string, OPENSSL_ERROR_LENGTH - 1);
    #####:  516:    err_string[OPENSSL_ERROR_LENGTH - 1] = '\0';
        -:  517:  }
    #####:  518:EXIT:
       18:  519:  return rc;
        -:  520:}
        -:  521:
        -:  522:/**
        -:  523:  Get fips mode from openssl library,
        -:  524:
        -:  525:  @returns openssl current fips mode
        -:  526:*/
    #####:  527:uint get_fips_mode() { return FIPS_mode(); }
        -:  528:
        -:  529:/**
        -:  530:  Toggle FIPS mode, to see whether it is available with the current SSL library.
        -:  531:  @retval 0 FIPS is not supported.
        -:  532:  @retval non-zero: FIPS is supported.
        -:  533:*/
    #####:  534:int test_ssl_fips_mode(char *err_string) {
    #####:  535:  int ret = FIPS_mode_set(FIPS_mode() == 0 ? 1 : 0);
    #####:  536:  unsigned long err = (ret == 0) ? ERR_get_error() : 0;
        -:  537:
    #####:  538:  if (err != 0) {
    #####:  539:    ERR_error_string_n(err, err_string, OPENSSL_ERROR_LENGTH - 1);
        -:  540:  }
    #####:  541:  return ret;
        -:  542:}
        -:  543:
       18:  544:long process_tls_version(const char *tls_version) {
       18:  545:  const char *separator = ",";
       18:  546:  char *token, *lasts = nullptr;
        -:  547:
        -:  548:#ifdef HAVE_TLSv13
       18:  549:  const char *tls_version_name_list[] = {"TLSv1", "TLSv1.1", "TLSv1.2",
        -:  550:                                         "TLSv1.3"};
       18:  551:  const char ctx_flag_default[] = "TLSv1,TLSv1.1,TLSv1.2,TLSv1.3";
       18:  552:  const long tls_ctx_list[] = {SSL_OP_NO_TLSv1, SSL_OP_NO_TLSv1_1,
        -:  553:                               SSL_OP_NO_TLSv1_2, SSL_OP_NO_TLSv1_3};
       18:  554:  long tls_ctx_flag = SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2 |
        -:  555:                      SSL_OP_NO_TLSv1_3;
        -:  556:#else
        -:  557:  const char *tls_version_name_list[] = {"TLSv1", "TLSv1.1", "TLSv1.2"};
        -:  558:  const char ctx_flag_default[] = "TLSv1,TLSv1.1,TLSv1.2";
        -:  559:  const long tls_ctx_list[] = {SSL_OP_NO_TLSv1, SSL_OP_NO_TLSv1_1,
        -:  560:                               SSL_OP_NO_TLSv1_2};
        -:  561:  long tls_ctx_flag = SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2;
        -:  562:#endif /* HAVE_TLSv13 */
       18:  563:  const unsigned int tls_versions_count = array_elements(tls_version_name_list);
       18:  564:  char tls_version_option[TLS_VERSION_OPTION_SIZE] = "";
       18:  565:  int tls_found = 0;
        -:  566:
      19*:  567:  if (!tls_version ||
        1:  568:      !my_strcasecmp(&my_charset_latin1, tls_version, ctx_flag_default))
       18:  569:    return 0;
        -:  570:
    #####:  571:  if (strlen(tls_version) - 1 > sizeof(tls_version_option)) return -1;
        -:  572:
    #####:  573:  strncpy(tls_version_option, tls_version, sizeof(tls_version_option));
    #####:  574:  token = my_strtok_r(tls_version_option, separator, &lasts);
    #####:  575:  while (token) {
    #####:  576:    for (unsigned int i = 0; i < tls_versions_count; i++) {
    #####:  577:      if (!my_strcasecmp(&my_charset_latin1, tls_version_name_list[i], token)) {
    #####:  578:        tls_found = 1;
    #####:  579:        tls_ctx_flag &= ~tls_ctx_list[i];
    #####:  580:        break;
        -:  581:      }
        -:  582:    }
    #####:  583:    token = my_strtok_r(nullptr, separator, &lasts);
        -:  584:  }
        -:  585:
    #####:  586:  if (!tls_found)
    #####:  587:    return -1;
        -:  588:  else
    #####:  589:    return tls_ctx_flag;
        -:  590:}
        -:  591:
        -:  592:/************************ VioSSLFd **********************************/
        1:  593:static struct st_VioSSLFd *new_VioSSLFd(
        -:  594:    const char *key_file, const char *cert_file, const char *ca_file,
        -:  595:    const char *ca_path, const char *cipher,
        -:  596:    const char *ciphersuites [[maybe_unused]], bool is_client,
        -:  597:    enum enum_ssl_init_error *error, const char *crl_file, const char *crl_path,
        -:  598:    const long ssl_ctx_flags, const char *server_host [[maybe_unused]]) {
        -:  599:  DH *dh;
        -:  600:  struct st_VioSSLFd *ssl_fd;
        1:  601:  long ssl_ctx_options = SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3;
        1:  602:  int ret_set_cipherlist = 0;
        2:  603:  std::string cipher_list;
        -:  604:#if OPENSSL_VERSION_NUMBER < 0x10002000L
        -:  605:  EC_KEY *eckey = nullptr;
        -:  606:#endif /* OPENSSL_VERSION_NUMBER < 0x10002000L */
        2:  607:  DBUG_TRACE;
       1*:  608:  DBUG_PRINT(
        -:  609:      "enter",
        -:  610:      ("key_file: '%s'  cert_file: '%s'  ca_file: '%s'  ca_path: '%s'  "
        -:  611:       "cipher: '%s' crl_file: '%s' crl_path: '%s' ssl_ctx_flags: '%ld' ",
        -:  612:       key_file ? key_file : "NULL", cert_file ? cert_file : "NULL",
        -:  613:       ca_file ? ca_file : "NULL", ca_path ? ca_path : "NULL",
        -:  614:       cipher ? cipher : "NULL", crl_file ? crl_file : "NULL",
        -:  615:       crl_path ? crl_path : "NULL", ssl_ctx_flags));
        -:  616:
        1:  617:  if (ssl_ctx_flags < 0) {
    #####:  618:    *error = SSL_TLS_VERSION_INVALID;
    #####:  619:    DBUG_PRINT("error", ("TLS version invalid : %s", sslGetErrString(*error)));
    #####:  620:    report_errors();
    #####:  621:    return nullptr;
        -:  622:  }
        -:  623:
        1:  624:  ssl_ctx_options = (ssl_ctx_options | ssl_ctx_flags) &
        -:  625:                    (SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1 |
        -:  626:                     SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2
        -:  627:#ifdef HAVE_TLSv13
        -:  628:                     | SSL_OP_NO_TLSv1_3
        -:  629:#endif /* HAVE_TLSv13 */
        -:  630:                     | SSL_OP_NO_TICKET);
        1:  631:  if (!(ssl_fd = ((struct st_VioSSLFd *)my_malloc(
        -:  632:            key_memory_vio_ssl_fd, sizeof(struct st_VioSSLFd), MYF(0)))))
    #####:  633:    return nullptr;
        -:  634:
        2:  635:  if (!(ssl_fd->ssl_context = SSL_CTX_new(is_client ?
        -:  636:#ifdef HAVE_TLSv13
    #####:  637:                                                    TLS_client_method()
        1:  638:                                                    : TLS_server_method()
        -:  639:#else  /* HAVE_TLSv13 */
        -:  640:                                                    SSLv23_client_method()
        -:  641:                                                    : SSLv23_server_method()
        -:  642:#endif /* HAVE_TLSv13 */
        -:  643:                                              ))) {
    #####:  644:    *error = SSL_INITERR_MEMFAIL;
    #####:  645:    DBUG_PRINT("error", ("%s", sslGetErrString(*error)));
    #####:  646:    report_errors();
    #####:  647:    my_free(ssl_fd);
    #####:  648:    return nullptr;
        -:  649:  }
        -:  650:
        -:  651:#ifdef HAVE_TLSv13
        -:  652:  /*
        -:  653:    Set OpenSSL TLS v1.3 ciphersuites.
        -:  654:    Note that an empty list is permissible.
        -:  655:  */
        1:  656:  if (nullptr != ciphersuites) {
        -:  657:    /*
        -:  658:      Note: if TLSv1.3 is enabled but TLSv1.3 ciphersuite list is empty
        -:  659:      (that's permissible and mentioned in the documentation),
        -:  660:      the connection will fail with "no ciphers available" error.
        -:  661:    */
    #####:  662:    if (0 == SSL_CTX_set_ciphersuites(ssl_fd->ssl_context, ciphersuites)) {
    #####:  663:      *error = SSL_INITERR_CIPHERS;
    #####:  664:      goto error;
        -:  665:    }
        -:  666:  }
        -:  667:#endif /* HAVE_TLSv13 */
        -:  668:
        -:  669:  /*
        -:  670:    We explicitly prohibit weak ciphers.
        -:  671:    NOTE: SSL_CTX_set_cipher_list will return 0 if
        -:  672:    none of the provided ciphers could be selected
        -:  673:  */
        1:  674:  cipher_list += tls_cipher_blocked;
        1:  675:  cipher_list += ":";
        -:  676:
        -:  677:  /*
        -:  678:    If ciphers are specified explicitly by caller, use them.
        -:  679:    Otherwise, fallback to the default list.
        -:  680:
        -:  681:    In either case, we make sure we stay within the valid bounds.
        -:  682:    Note that we have already consumed tls_cipher_blocked
        -:  683:    worth of space.
        -:  684:  */
        1:  685:  if (cipher == nullptr) {
        1:  686:    std::stringstream sstream;
        -:  687:    sstream << mandatory_p1 << ":" << optional_a1 << ":" << optional_a2 << ":"
        1:  688:            << optional_d1;
        1:  689:    cipher_list.append(sstream.str());
        -:  690:  } else
    #####:  691:    cipher_list.append(cipher);
        -:  692:
        1:  693:  if (ret_set_cipherlist ==
        1:  694:      SSL_CTX_set_cipher_list(ssl_fd->ssl_context, cipher_list.c_str())) {
    #####:  695:    *error = SSL_INITERR_CIPHERS;
    #####:  696:    goto error;
        -:  697:  }
        -:  698:
        -:  699:  /* Load certs from the trusted ca */
        1:  700:  if (SSL_CTX_load_verify_locations(ssl_fd->ssl_context, ca_file, ca_path) <=
        -:  701:      0) {
       1*:  702:    DBUG_PRINT("warning", ("SSL_CTX_load_verify_locations failed"));
        1:  703:    if (ca_file || ca_path) {
        -:  704:      /* fail only if ca file or ca path were supplied and looking into
        -:  705:         them fails. */
    #####:  706:      DBUG_PRINT("warning", ("SSL_CTX_load_verify_locations failed"));
    #####:  707:      *error = SSL_INITERR_BAD_PATHS;
    #####:  708:      goto error;
        -:  709:    }
        -:  710:
        -:  711:    /* otherwise go use the defaults */
        1:  712:    if (SSL_CTX_set_default_verify_paths(ssl_fd->ssl_context) == 0) {
    #####:  713:      *error = SSL_INITERR_BAD_PATHS;
    #####:  714:      goto error;
        -:  715:    }
        -:  716:  }
        -:  717:
        1:  718:  if (crl_file || crl_path) {
    #####:  719:    X509_STORE *store = SSL_CTX_get_cert_store(ssl_fd->ssl_context);
        -:  720:    /* Load crls from the trusted ca */
    #####:  721:    if (X509_STORE_load_locations(store, crl_file, crl_path) == 0 ||
    #####:  722:        X509_STORE_set_flags(
        -:  723:            store, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL) == 0) {
    #####:  724:      DBUG_PRINT("warning", ("X509_STORE_load_locations for CRL failed"));
    #####:  725:      *error = SSL_INITERR_BAD_PATHS;
    #####:  726:      goto error;
        -:  727:    }
        -:  728:  }
        -:  729:
        1:  730:  if (vio_set_cert_stuff(ssl_fd->ssl_context, cert_file, key_file, error)) {
    #####:  731:    DBUG_PRINT("warning", ("vio_set_cert_stuff failed"));
    #####:  732:    goto error;
        -:  733:  }
        -:  734:
        -:  735:  /* Server specific check : Must have certificate and key file */
        1:  736:  if (!is_client && !key_file && !cert_file) {
        1:  737:    *error = SSL_INITERR_NO_USABLE_CTX;
        1:  738:    goto error;
        -:  739:  }
        -:  740:
        -:  741:  /* DH stuff */
    #####:  742:  dh = get_dh2048();
    #####:  743:  if (SSL_CTX_set_tmp_dh(ssl_fd->ssl_context, dh) == 0) {
    #####:  744:    DH_free(dh);
    #####:  745:    *error = SSL_INITERR_DHFAIL;
    #####:  746:    goto error;
        -:  747:  }
    #####:  748:  DH_free(dh);
        -:  749:
        -:  750:  /* ECDH stuff */
        -:  751:#if OPENSSL_VERSION_NUMBER < 0x10002000L
        -:  752:  /* We choose P-256 curve. */
        -:  753:  eckey = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
        -:  754:  if (!eckey) {
        -:  755:    *error = SSL_INITERR_ECDHFAIL;
        -:  756:    goto error;
        -:  757:  }
        -:  758:  if (SSL_CTX_set_tmp_ecdh(ssl_fd->ssl_context, eckey) != 1) {
        -:  759:    EC_KEY_free(eckey);
        -:  760:    *error = SSL_INITERR_ECDHFAIL;
        -:  761:    goto error;
        -:  762:  }
        -:  763:#else
        -:  764:  if (SSL_CTX_set_ecdh_auto(ssl_fd->ssl_context, 1) == 0) {
        -:  765:    *error = SSL_INITERR_ECDHFAIL;
        -:  766:    goto error;
        -:  767:  }
        -:  768:#endif /* OPENSSL_VERSION_NUMBER < 0x10002000L */
        -:  769:
        -:  770:#if OPENSSL_VERSION_NUMBER >= 0x10002000L
        -:  771:  /*
        -:  772:    OpenSSL 1.0.2 and up provides support for hostname validation.
        -:  773:    If server_host parameter is set it contains either IP address or
        -:  774:    server's hostname. Pass it to the lib to perform automatic checks.
        -:  775:  */
    #####:  776:  if (server_host) {
    #####:  777:    X509_VERIFY_PARAM *param = SSL_CTX_get0_param(ssl_fd->ssl_context);
    #####:  778:    assert(is_client);
        -:  779:    /*
        -:  780:      As we don't know if the server_host contains IP addr or hostname
        -:  781:      call X509_VERIFY_PARAM_set1_ip_asc() first and if it returns an error
        -:  782:      (not valid IP address), call X509_VERIFY_PARAM_set1_host().
        -:  783:    */
    #####:  784:    if (1 != X509_VERIFY_PARAM_set1_ip_asc(param, server_host)) {
    #####:  785:      if (1 != X509_VERIFY_PARAM_set1_host(param, server_host, 0)) {
    #####:  786:        *error = SSL_INITERR_X509_VERIFY_PARAM;
    #####:  787:        goto error;
        -:  788:      }
        -:  789:    }
        -:  790:  }
        -:  791:#endif
        -:  792:
    #####:  793:  SSL_CTX_set_options(ssl_fd->ssl_context, ssl_ctx_options);
        -:  794:
    #####:  795:  DBUG_PRINT("exit", ("OK 1"));
        -:  796:
    #####:  797:  return ssl_fd;
        -:  798:
        1:  799:error:
       1*:  800:  DBUG_PRINT("error", ("%s", sslGetErrString(*error)));
        1:  801:  report_errors();
        1:  802:  SSL_CTX_free(ssl_fd->ssl_context);
        1:  803:  my_free(ssl_fd);
        1:  804:  return nullptr;
        -:  805:}
        -:  806:
        -:  807:/************************ VioSSLConnectorFd
        -:  808: * **********************************/
    #####:  809:struct st_VioSSLFd *new_VioSSLConnectorFd(
        -:  810:    const char *key_file, const char *cert_file, const char *ca_file,
        -:  811:    const char *ca_path, const char *cipher, const char *ciphersuites,
        -:  812:    enum enum_ssl_init_error *error, const char *crl_file, const char *crl_path,
        -:  813:    const long ssl_ctx_flags, const char *server_host) {
        -:  814:  struct st_VioSSLFd *ssl_fd;
    #####:  815:  int verify = SSL_VERIFY_PEER;
        -:  816:
        -:  817:  /*
        -:  818:    Turn off verification of servers certificate if both
        -:  819:    ca_file and ca_path is set to NULL
        -:  820:  */
    #####:  821:  if (ca_file == nullptr && ca_path == nullptr) verify = SSL_VERIFY_NONE;
        -:  822:
    #####:  823:  if (!(ssl_fd = new_VioSSLFd(key_file, cert_file, ca_file, ca_path, cipher,
        -:  824:                              ciphersuites, true, error, crl_file, crl_path,
        -:  825:                              ssl_ctx_flags, server_host))) {
    #####:  826:    return nullptr;
        -:  827:  }
        -:  828:
        -:  829:  /* Init the VioSSLFd as a "connector" ie. the client side */
        -:  830:
    #####:  831:  SSL_CTX_set_verify(ssl_fd->ssl_context, verify, nullptr);
        -:  832:
    #####:  833:  return ssl_fd;
        -:  834:}
        -:  835:
        -:  836:/************************ VioSSLAcceptorFd **********************************/
        1:  837:struct st_VioSSLFd *new_VioSSLAcceptorFd(
        -:  838:    const char *key_file, const char *cert_file, const char *ca_file,
        -:  839:    const char *ca_path, const char *cipher, const char *ciphersuites,
        -:  840:    enum enum_ssl_init_error *error, const char *crl_file, const char *crl_path,
        -:  841:    const long ssl_ctx_flags) {
        -:  842:  struct st_VioSSLFd *ssl_fd;
        1:  843:  int verify = SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE;
        1:  844:  if (!(ssl_fd = new_VioSSLFd(key_file, cert_file, ca_file, ca_path, cipher,
        -:  845:                              ciphersuites, false, error, crl_file, crl_path,
        -:  846:                              ssl_ctx_flags, nullptr))) {
        1:  847:    return nullptr;
        -:  848:  }
        -:  849:  /* Init the the VioSSLFd as a "acceptor" ie. the server side */
        -:  850:
        -:  851:  /* Set max number of cached sessions, returns the previous size */
    #####:  852:  SSL_CTX_sess_set_cache_size(ssl_fd->ssl_context, 128);
        -:  853:
    #####:  854:  SSL_CTX_set_verify(ssl_fd->ssl_context, verify, nullptr);
        -:  855:
        -:  856:  /*
        -:  857:    Set session_id - an identifier for this server session
        -:  858:    Use the ssl_fd pointer
        -:  859:   */
    #####:  860:  SSL_CTX_set_session_id_context(ssl_fd->ssl_context,
        -:  861:                                 (const unsigned char *)ssl_fd, sizeof(ssl_fd));
        -:  862:
    #####:  863:  return ssl_fd;
        -:  864:}
        -:  865:
    #####:  866:void free_vio_ssl_acceptor_fd(struct st_VioSSLFd *fd) {
    #####:  867:  SSL_CTX_free(fd->ssl_context);
    #####:  868:  my_free(fd);
    #####:  869:}
